# 帧同步学习：预测和回滚

现在我们开始讨论预测与回滚的问题

我们首先需要梳理清楚，服务器和客户端对于用户操作的同步机制：帧同步的核心是基于服务器的权威性，保证所有客户端的状态一致，这是最核心的目的！

基于此，我们首先讨论关于Tick的问题：

## Tick

Tick，我们可以理解为帧，或者是心跳一类的东西，代表了从游戏开始到现在已经模拟了多少次。

Tick分为两类：一类是权威帧，一类是逻辑帧。（就让我这样命名吧）

权威帧是服务器所保证记录的到目前为止的帧，这是最权威，唯一的确定的计数。

逻辑帧是客户端自己记录的自身从开始到现在模拟运行的帧数，这个帧数的记录的目的是为了保证客户端模拟的和客户端一致，从而决定是否需要追帧，预测和回滚到哪里。

## 客户端的地位一致性

首先帧同步必须要明白这样一个问题：所有的帧同步下的客户端的地位是完全一致的。这句话的意思是，在帧同步下，所有的客户端的状态，都同样是由服务器决定的，即使客户端能直接获取自己客户端的本地输入。

看一个场景：

> 比如说我是用户A，我的客户端是A，因为网络延迟导致我明明有输入但是发给服务器晚了，服务器认为我没有输入，而这时后我本地模拟了一个输入（比如说延续上一帧的移动状态（但实际上服务器认为我没有任何输入也就是没有移动）。

当发生了这样的情况的时候，我们的客户端A提前预测了下一帧的操作（根据本地输入移动，或者是延续上一帧的移动），而可能由于网络延迟，导致这一帧的操作没法即使传到服务器，而服务器是定时广播的，如果一个客户端的操作迟迟没有传来，那么服务器就会把他作为“未操作来处理”。然后再广播

这时候客户端A收到了服务器的消息，客户端A发现，现在他预测的帧的操作和服务器发来的不操作的帧的操作不一致，那就需要回滚

这里就体现出一个问题：就是无论如何，服务器才是权威，任何一个客户端都需要根据服务器的状态修正自身状态，即使服务器的状态不是我们预期的。

看一下Gemini的解释：

> 我突然有这样一个疑问，就是对于帧同步来说，所有的客户端的地位都是完全一致的对吗。比如说我是用户A，我的客户端是A，那其实对于我自己的客户端，他的权威数据依然需要看服务器那边如何决定。比如因为网络延迟导致我明明有输入但是发给服务器晚了，服务器认为我没有输入，那这样也依然需要回滚 
>
> 您提的这个问题非常棒，触及了帧同步架构中一个核心且容易混淆的点！
>
> 您的理解是**完全正确**的。
>
> **对于帧同步来说，虽然客户端会进行预测以提供即时反馈，但最终的“权威”状态是由服务器决定的。所有客户端，包括操作者自己的客户端，都必须以服务器广播的权威帧数据为准。**
>
> 让我们详细解释一下您提出的情况：
>
> > 比如说我是用户A，我的客户端是A，那其实对于我自己的客户端，他的权威数据依然需要看服务器那边如何决定。比如因为网络延迟导致我明明有输入但是发给服务器晚了，服务器认为我没有输入，那这样也依然需要回滚。
>
> 这正是帧同步的工作方式，也是它与状态同步（State Synchronization，例如很多FPS游戏采用的）的一个关键区别。
>
> #### 客户端的“预测”与服务器的“权威”
>
> 1. **客户端A的本地预测**：
>
>    - 当您（用户A）在客户端A上进行操作（例如，按下前进键）时，客户端A为了不让您感觉到延迟，会**立即**根据这个输入进行一次“预测性”的模拟。您的角色在屏幕上会立刻向前移动。
>    - 同时，客户端A会将这个“前进操作”以及它发生的目标逻辑帧号（比如Tick 100）发送给服务器。这是在 `SimulatorService.SendInputs()` 中完成的。
>    - 客户端A会将这个自己产生的、带有Tick 100的输入帧存储在 `FrameBuffer` 的 `_clientBuffer` 中。
>
> 2. **服务器的处理**：
>
>    - 服务器会尝试收集所有客户端在Tick 100的操作。
>    - **关键点**：由于网络延迟，您客户端A发送的“前进操作（Tick 100）”可能没有在服务器处理Tick 100的“截止时间”之前到达。
>    - 如果服务器在处理Tick 100时，没有收到客户端A在该Tick的操作，服务器可能会做出以下几种判断（具体策略取决于服务器实现）：
>      - **认为客户端A在Tick 100无操作** (最常见且简单的处理方式)。
>      - **使用客户端A在Tick 99的操作作为Tick 100的操作** (一种服务器端的输入填充/预测)。
>      - （不太常见）等待一个极短的时间，如果还未收到，则认为无操作。
>
> 3. **服务器广播权威帧**：
>
>    - 假设服务器最终判定客户端A在Tick 100时“无操作”（或者用了A在Tick 99的操作，而A在Tick 99是静止的）。
>    - 服务器会将这个包含了“客户端A在Tick 100无操作”的权威`ServerFrame`（帧号为Tick 100）广播给所有客户端，包括客户端A。
>
> 4. **客户端A接收权威帧并处理**：
>
>    - 客户端A的 `FrameBuffer` 接收到这个来自服务器的、帧号为Tick 100的权威`ServerFrame`，并将其存入 `_serverBuffer`。
>
>    - 在 
>
>      ```
>      FrameBuffer.DoUpdate()
>      ```
>
>       中，会进行比对：
>
>      - 客户端A之前自己预测并存储在 `_clientBuffer` 中的Tick 100的帧，包含了“前进操作”。
>      - 服务器发来的、存储在 `_serverBuffer` 中的Tick 100的帧，包含了“无操作”。
>      - **两者不一致！** (`sFrame.Equals(cFrame)` 返回 `false`)
>
>    - 因此，`_cmdBuffer.IsNeedRollback` 会被设置为 `true`。
>
> 5. **客户端A执行回滚**：
>
>    - `SimulatorService.DoNormalUpdate()` 检测到 `_cmdBuffer.IsNeedRollback` 为 `true`。
>    - 调用 `RollbackTo(_cmdBuffer.NextTickToCheck, ...)`，其中 `_cmdBuffer.NextTickToCheck` 此时就是Tick 100。
>    - **客户端A的状态会回滚到Tick 99结束时的状态。**
>    - 然后，客户端A会使用服务器发来的权威`ServerFrame`（Tick 100，其中A无操作）重新模拟Tick 100的逻辑。
>    - **结果**：在客户端A的屏幕上，您可能会看到您的角色本来在Tick 100向前动了一下（因为本地预测），但在收到服务器权威帧并回滚后，角色又“闪回”到了Tick 99的位置，并在Tick 100时保持不动（或执行服务器认定的操作）。
>    - 随后，如果您的“前进操作”最终在服务器处理Tick 101或之后被采纳，那么您的角色才会在那个权威的Tick上真正前进。
>
> #### 为什么必须这样做？
>
> - **一致性是首要目标**：帧同步的核心是保证所有客户端在每一个逻辑帧结束时，游戏状态是完全一致的。只有以唯一的权威源（服务器）的判定为准，才能实现这一点。
> - **公平性**：如果允许客户端自己的“迟到”操作强行改变历史，那么网络状况好的玩家将比网络状况差的玩家更有优势，或者会导致不同客户端看到的游戏结果不一致。
> - **防止作弊**：如果客户端可以单方面决定自己的操作结果，而不受服务器的最终裁定，这将为作弊打开方便之门。
>
> #### 客户端的“自主权”体现在哪里？
>
> 客户端的“自主权”主要体现在**预测执行**上，是为了**本地体验的流畅性**。它可以在等待服务器权威数据的过程中，提前模拟未来的帧，让玩家感觉操作是即时的。但这种自主权是**有条件的、可撤销的**。一旦服务器的权威数据到来，任何与权威数据不符的预测都必须被纠正（通过回滚）。
>
> **总结来说，您的问题点出了帧同步的一个核心设计哲学：为了保证所有参与者之间游戏状态的绝对一致，服务器扮演了最终仲裁者的角色。每个客户端，即使是对于其自身的操作，也必须服从服务器整合并广播的权威指令集。本地预测是为了优化体验，但不能凌驾于全局一致性之上。因此，即使是本地玩家的操作，如果因为网络原因未被服务器及时采纳到对应的权威帧中，客户端在收到该权威帧后也必须回滚本地的预测，并以服务器的数据为准重新模拟。**
>
> 这就是为什么在网络状况不佳的帧同步游戏中，玩家有时会体验到“拉扯感”或“回溯感”——这正是客户端在不断地进行预测、接收权威数据、发现不一致、然后回滚并重模拟的过程。

## 服务器的权威一致性

服务器是如何对待滞后的客户端帧？

一般就是直接扔，服务器维护的是权威帧，而客户端维护的是逻辑帧，滞后了就滞后了，直接扔

> 第二个问题是，服务器如何对待后来到达的在权威帧之前的客户端发送的逻辑帧 
>
> 您好！关于您第二个问题：“服务器如何对待后来到达的、在权威帧之前的客户端发送的逻辑帧”，这涉及到服务器端帧同步逻辑的一个重要方面——**处理迟到的客户端输入 (Late Inputs)**。
>
> 虽然我们主要分析的是客户端代码，但根据标准的帧同步设计和客户端的行为模式，我们可以合理推断服务器端的处理方式。
>
> **核心原则：服务器不会因为迟到的输入而“改变历史”或“重新广播”已经发出的权威帧。**
>
> 一旦服务器为某个逻辑帧 `T` （我们称之为“权威帧 `T`”）收集了所有（或超时认为已收集完毕）客户端的输入，并将这个权威帧 `T` 广播给了所有客户端，那么权威帧 `T` 的内容（即所有玩家在该帧的操作集合）就被**最终确定 (Finalized)** 了。
>
> 对于那些**目标帧号小于或等于当前服务器正在处理或已经处理并广播完毕的权威帧号**的、后来才到达的客户端输入（即“迟到输入”），服务器通常会采取以下几种策略之一，或者组合策略：
>
> #### 1. 直接丢弃 (Most Common and Simplest)
>
> - **描述**：这是最常见也是最简单的处理方式。如果服务器当前正在处理（或已经处理完）Tick `N`，这时收到一个客户端发来的、声称是为 Tick `M`（其中 `M <= N`）的操作，服务器会直接忽略或丢弃这个操作。
>
> - 理由
>
>   ：
>
>   - **维护一致性**：权威帧 `M` 的内容已经被确定并广播，不能再被修改。修改历史会导致所有客户端都需要进行更复杂的回滚和状态修正，甚至可能引发连锁反应。
>   - **简化服务器逻辑**：服务器不需要缓存这些迟到的历史输入，也不需要尝试将它们“塞回”历史帧中。
>   - **公平性**：所有客户端都必须在服务器为某一帧设定的“输入收集窗口期”内提交操作。迟到的操作被忽略，是对遵守时间窗口的玩家的公平对待。
>
> - **客户端表现**：如我们之前讨论的，如果客户端A的操作因为网络延迟，在服务器处理完Tick `M` 后才到达，那么服务器在生成权威帧 `M` 时可能认为A无操作。客户端A在收到这个权威帧后，即使它本地预测了操作，也必须回滚到服务器认定的状态。那个迟到的操作就“丢失”了，不会对游戏状态产生影响，除非玩家在后续的帧中重新执行类似操作并被服务器及时采纳。
>
> #### 2. 尝试应用到未来的某个帧 (Less Common for Pure Lockstep)
>
> - **描述**：在某些不那么严格的帧同步或混合同步模型中，服务器可能会尝试将一个迟到的、本应属于Tick `M` 的操作，应用到服务器当前正在处理的、尚未广播的未来某个帧 `N+1` 或 `N+2` 上。
>
> - 理由
>
>   ：
>
>   - **尽量不丢失玩家意图**：尝试保留玩家的操作意图，即使它错过了原始的目标帧。
>
> - 挑战与复杂性
>
>   ：
>
>   - **操作的有效性**：一个在Tick `M` 时有效的操作（例如，攻击一个当时在范围内的敌人），到了Tick `N+1` 时可能已经不再有效（敌人可能已经移动或死亡）。服务器需要复杂的逻辑来判断这个“过期”操作是否还能合理地应用。
>   - **玩家体验**：玩家可能会看到自己的操作在一个意想不到的时间点被执行，这可能比操作被直接忽略更令人困惑。
>   - **不适用于严格帧同步**：在严格的帧同步中，每一帧的输入都必须是确定的。将历史输入挪到未来帧会破坏这种确定性，并可能导致不同客户端在“未来帧”上产生不同的预测基础。
>
> - **适用场景**：这种策略更可能出现在一些对输入时效性要求不那么极致，或者服务器有更多自主权的同步模型中，而非纯粹的Lockstep。
>
> #### 3. 记录并通知客户端 (Rare, for debugging or specific game mechanics)
>
> - **描述**：服务器记录下这个迟到的输入，并且可能通过某种方式（例如一个非关键的游戏事件消息）通知客户端“你的某个操作因为太迟而未被采纳到XX帧”。
>
> - 理由
>
>   ：
>
>   - **调试和分析**：帮助开发者了解网络状况和输入延迟问题。
>   - **特定游戏机制反馈**：如果游戏设计中有机制需要告知玩家其操作的成功与否及原因。
>
> - **复杂性**：增加了服务器的记录负担和额外的网络通信。对核心同步逻辑没有直接帮助。
>
> #### 为什么服务器不为迟到输入而重新广播权威帧？
>
> - **网络风暴**：如果服务器因为一个客户端的迟到输入就修改历史并重新广播权威帧，那么其他所有已经收到并处理了旧权威帧的客户端都需要进行回滚。如果这种情况频繁发生，会导致网络中充斥着大量的重发数据和状态修正信息，形成“网络风暴”，严重影响游戏体验。
> - **状态不确定性延长**：权威帧一旦广播，客户端就将其视为“黄金标准”进行后续的预测和模拟。如果这个“黄金标准”本身可以被轻易修改，那么客户端的预测基础会变得非常不稳定，回滚会更加频繁和剧烈。
> - **处理复杂度剧增**：服务器需要维护所有历史帧的多个版本，或者能够精确地撤销和重做历史操作，这会使服务器逻辑变得异常复杂。
>
> #### 客户端如何应对“被忽略”的迟到操作？
>
> 从客户端的角度看（我们主要分析的是客户端代码）：
>
> - 客户端通过 `SimulatorService.SendInputs()` 尽早地（根据 `PreSendInputCount`）将本地操作发送出去。
> - 客户端本地会立即使用这个操作进行预测，存储在 `_clientBuffer`。
> - 当服务器的权威帧 `ServerFrame` 到达后（存储在 `_serverBuffer`），客户端会比较 `_clientBuffer` 和 `_serverBuffer` 中对应Tick的帧。
> - 如果因为本地操作发送迟了，导致服务器的权威帧中没有包含这个操作（或者包含了不同的操作），那么比较结果就会是“不一致”。
> - 客户端会触发回滚 (`IsNeedRollback = true`)，游戏状态退回到该权威帧的前一帧，然后使用权威帧的数据（其中本地玩家可能无操作或执行了服务器认定的操作）重新模拟这一帧。
>
> **这意味着，对于因为网络延迟而“迟到”的、且其目标帧已经被服务器处理并广播的客户端输入，它们实际上是被服务器“抛弃”了。客户端的责任是通过本地回滚机制来接受并适应这个由服务器决定的权威历史。**
>
> **总结**：
>
> 在您提供的这个帧同步框架（以及大多数标准的帧同步实现）中，服务器对于那些**目标逻辑帧号早于或等于当前已广播权威帧号**的“迟到”客户端输入，最普遍和合理的处理方式是**直接丢弃**。服务器不会为了这些迟到的输入去修改已经板上钉钉的历史。客户端则通过预测和回滚机制来适应这种情况，保证最终与服务器的权威状态一致，即使这意味着它自己先前预测的、但因迟到而未被服务器采纳的操作会被“抹去”。
>
> 这种设计确保了帧同步的核心目标：**所有客户端最终在每一逻辑帧上都达到完全一致的游戏状态**

## 客户端的逻辑tick相对于服务器权威tick落后了：客户端追帧：

客户端维护当前的逻辑tick

服务器发送一个权威tick

当客户端的逻辑tick相对于服务器权威tick落后了了·

然后比较逻辑tick和权威tick

如果落后了，就追帧

追帧就是在一次update当中快速的模拟，直到追上服务器的帧数

## 客户端的逻辑tick和服务器权威tick一致：客户端的预测

当客户端的逻辑tick和服务器权威tick一致了（不一定是真的一致，有可能因为延迟。。。）

那就要开始预测，往下预测一帧，采用的是沿用上一帧的输入

## 客户端的逻辑tick和服务器权威tick超前：客户端的回滚

当客户端的逻辑tick和服务器权威tick超前

通过直接比较两个帧之间的输入数据，如果预测一致，那就不需要回滚，如果发现预测的帧和实际的权威帧状态不一致，那就要回滚。