# 帧同步学习：碰撞检测

## 架构设计

整体的架构设计是构建一个管理碰撞的Manager，然后对于可碰撞对象抽象为一个CollisionProxy，然后在创建的时候把他注册进管理系统

## **ColliderProxy**：

代表场景中的可碰撞对象，管理其形状、变换和碰撞事件。

> **碰撞体代理 (`ColliderProxy.cs`)**
>
> - 核心类，场景中实际参与碰撞检测的对象。
> - `EntityObject`: 关联的业务逻辑对象。
> - `Id`: 唯一标识符。
> - `LayerType`: 碰撞层，用于过滤碰撞。
> - `Prefab`: `ColliderPrefab` 实例，定义了碰撞体的形状。
> - `Transform2D`: 该碰撞体在世界空间中的变换。  
> - `Height`: 物体的3D高度信息（可能与 `Transform2D.y` 有关或互补）。
> - `IsTrigger`: 是否为触发器（不产生物理碰撞效果，仅触发事件）。
> - `IsStatic`: 是否为静态物体（不移动，优化碰撞检测）。
> - `_prePos`, `_preDeg`: 用于检测物体是否移动或旋转，以决定是否需要更新其在四叉树中的位置。
> - `_bound`: 预计算的本地包围盒。
> - `GetBounds()`: 获取物体在世界空间中的AABB（本地包围盒+世界位置）。
> - `OnTriggerEvent`: 碰撞事件回调委托。
> - 实现了 `ILPCollisionEventHandler` 和 `ILPTriggerEventHandler` 接口，包含 `OnLPTriggerEnter/Stay/Exit` 和 `OnLPCollisionEnter/Stay/Exit` 事件处理虚方法。

## 碰撞注册

在对应的实例（Entity）创建的时候，会首先把对应的实例上的ColliderProxy注册到ColliderManager当中。

CollisionManager在每一帧都会调用DoUpdate，然后会调用到CollisionSystem的DoUpdate

然后在CollidsionSystem当中，会按照以下思路：

1. 确定哪些物体可能会改变碰撞状态=>根据的是有碰撞能力的物体是否移动
2. 根据可能会发生新碰撞的物体，更新四叉树结构
3. 为了实现碰撞事件的触发（进入，离开，Stay），需要一个双缓冲，存储上一帧发生碰撞的物体以及当前帧发生碰撞的物体来比对
4. 碰撞检测（依靠四叉树）
   1. 粗粒度碰撞检测，根据四叉树，找到可能发生碰撞物体处于哪个四叉树节点
   2. 细粒度检测，检测四叉树叶子节点的物体和碰撞。（CollisionHelper1：CheckCollision）
5. 触发碰撞事件