# 动态图集

动态图集解决一个问题：

> 比如有两个Icon，这俩Icon打包在两个图集里面，这俩图集又分别在两个AB包里面
>
> 现在一个复杂UI，用了这俩图，一个图集里面的可以合批，但是两个图集里的就没法合批了，而且因为这是运行时赋值的sprite，所以也没法提前打图集
>
> 动态图集就是在运行时打一个大的Texture，把这俩Icon的图都复制进去，这样就可以合批了。
>
> 并且如果之后还有用这俩图的，直接拿引用，依然可以享受这种好处

## 图集分配

TryAllocate尝试分配一个大的图集，DynamicAtlasManager当中GetSprite的时候调用。

可以这样理解，我们传入一个Sprite，这个Sprite会被插入到Tex当中，并且生成一个新的Sprite，后面的使用的都是这个Sprite

```c#
using UnityEngine;

namespace Framework.UI.Component
{
    
    public class DynamicAtlasPage
    {
        public Texture2D MainTexture { get; private set; }
        private int _width, _height;
        private int _cursorX, _cursorY;
        private int _maxRowHeight;
        private const int PADDING = 2;

        public int ActiveSpriteCount = 0;  //当前这页有多少个活跃 Sprite
        public DynamicAtlasPage(int size)
        {
            _width = size;
            _height = size;
            MainTexture = new Texture2D(_width, _height, TextureFormat.RGBA32, false);
            // 初始化个颜色防止某些平台报错，实际全透明
            Color32[] cls = new Color32[1];
            MainTexture.SetPixels32(0,0,1,1, cls); 
            MainTexture.Apply();
        }

        public bool TryAllocate(int w, int h, out Vector2Int pos)
        {
            pos = Vector2Int.zero;
            //如果图片特别大，就直接返回了
            if (w > _width || h > _height) 
            {
                return false;
            }
            
            if (_cursorX + w + PADDING > _width) //当前这一行剩下的空间，不够放了
            {
                _cursorX = 0; // 换行
                _cursorY += _maxRowHeight + PADDING; //使用上一行已有的最大高度来结算上一行的图
                _maxRowHeight = 0;
            }
            if (_cursorY + h + PADDING > _height) return false;

            pos = new Vector2Int(_cursorX, _cursorY);
            _cursorX += w + PADDING;
            if (h > _maxRowHeight) _maxRowHeight = h;
            return true;
        }
        
        public void Release()
        {
            if (MainTexture != null)
            {
                UnityEngine.Object.Destroy(MainTexture);
                MainTexture = null;
            }
        }
    }
}
```



## 图集压缩格式，排布方式等问题的处理

有一个关键的问题是，图集当中的图是会压缩的，所以我们如果直接取出来然后放到新的动态的贴图当中是有问题的。这里的一个Trick是借助Unity的底层，使用一个Shader，去图集上采样，然后把采样的结果会知道一个RT上，然后再把这个RT上的像素复制到Tex上

```c#
        private Sprite InsertSpriteToPage(DynamicAtlasPage page, Sprite source)
        {
            int width = (int)source.rect.width;
            int height = (int)source.rect.height;

            // 申请位置
            if (!page.TryAllocate(width, height, out Vector2Int pos)) return null;

            // 使用 RenderTexture + Blit 解决格式和 UV 截取问题
            RenderTexture tempRT = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.ARGB32);
            RenderTexture old = RenderTexture.active;
            RenderTexture.active = tempRT;
            GL.Clear(true, true, Color.clear);

            // 计算 Scale 和 Offset 用于 Shader 截取
            Vector4 scaleOffset = GetSpriteUVScaleOffset(source);
            if (_blitMat != null)
            {
                _blitMat.SetVector("_MainTex_ST", scaleOffset);
                Graphics.Blit(source.texture, tempRT, _blitMat);
            }
            else
            {
                // 直接 Blit 全图
                Graphics.Blit(source.texture, tempRT);
            }

            // Copy 到动态图集
            Graphics.CopyTexture(tempRT, 0, 0, 0, 0, width, height, page.MainTexture, 0, 0, pos.x, pos.y);

            RenderTexture.active = old;
            RenderTexture.ReleaseTemporary(tempRT);

            // 创建新 Sprite
            Rect rect = new Rect(pos.x, pos.y, width, height);
            // 保持原 Pivot
            Vector2 pivot = new Vector2(source.pivot.x / source.rect.width, source.pivot.y / source.rect.height);
            return Sprite.Create(page.MainTexture, rect, pivot);
        }

        private Vector4 GetSpriteUVScaleOffset(Sprite sp)
        {
            // 适用于矩形 Packing
            float minX = float.MaxValue, minY = float.MaxValue;
            float maxX = float.MinValue, maxY = float.MinValue;

            foreach (var uv in sp.uv)
            {
                if (uv.x < minX) minX = uv.x;
                if (uv.y < minY) minY = uv.y;
                if (uv.x > maxX) maxX = uv.x;
                if (uv.y > maxY) maxY = uv.y;
            }

            // _MainTex_ST: x=TilingX, y=TilingY, z=OffsetX, w=OffsetY
            return new Vector4(maxX - minX, maxY - minY, minX, minY);
        }
```

Shader的内容如下：

```c++
Shader "Hidden/BlitCopy"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            struct appdata {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST; // 系统自动传入 Tiling(XY) 和 Offset(ZW)

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                // 应用 Scale 和 Offset 截取大图的局部
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                return tex2D(_MainTex, i.uv);
            }
            ENDCG
        }
    }
}
```





## 回收：引用计数

释放的时候使用ReleaseSprite，这个ReleaseSprite是在DynamicImage当中调用，Release的依据是根据引用计数来的：

> 释放两个东西：
>
> 1. 对于Sprite，减少引用计数，如果小于等于0就直接释放，注意，这里不会同时释放移动Page的cursor，这是因为这样的释放是很复杂的，而且很有可能只有的图也没法放进来。我的一个优化的思路是：当Page里的空间小于一定量之后，重新重构整个Page的排布，把里面还存在的图的位置重新分配一遍，这样相当于是重新整理空间
> 2. 如果一个Page里的activeSprite为空就直接释放

```c#
class DynamicAtlasManager{
    public void ReleaseSprite(Sprite sourceSprite)
        {
            if (sourceSprite == null) return;

            string key = sourceSprite.GetInstanceID().ToString();
            
            if (_spriteCache.TryGetValue(key, out PackedSpriteInfo info))
            {
                info.refCount--;
                // Debug.Log($"[DynamicAtlas] 引用减少: {sourceSprite.name}, Count={info.refCount}");
                if (info.refCount <= 0)
                {
                    // 引用归零, 移除缓存
                    _spriteCache.Remove(key);
                    Destroy(info.packedSprite); // 销毁生成的 Sprite 对象

                    // Page 计数减少
                    if (info.page != null)
                    {
                        info.page.ActiveSpriteCount--;
                        
                        // 检查 Page 是否彻底空了
                        if (info.page.ActiveSpriteCount <= 0)
                        {
                            RecyclePage(info.page);
                        }
                    }
                }
            }
        }
}
```

