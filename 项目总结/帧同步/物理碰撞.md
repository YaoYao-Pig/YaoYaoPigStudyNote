# 物理碰撞



## 确定性保证：

先看俩，一个是确定的碰撞一个是碰撞结果不确定
![不确定碰撞](assets/不确定碰撞.gif)



![确定碰撞](assets/确定碰撞.gif)

为啥会这样的，下面几条总结

### 排序造成的问题

需要一个确定性排序

八叉树，EPA都会受到访问检测顺序的影响

### 回滚备份

为了保证这种确定性，必须要备份可物理交互物体的物理信息（看Interactive）



## EPA + 基于冲量的解算器

### EPA的意义

EPA的输入是GJK的输出的单纯形，对于两个碰撞的物体，让他俩分开，其实就等价于，把闵可夫斯基差构造的凸体的原点，移动到边界上，我们当然是要找到一个最近的边界，因此EPA就是，找到这样一个边界，距离原点最近，然后返回值就是一个向量，这个向量的方向就是两个物体移动的方向（和反方向），向量的长度就是具体推动多少距离



### EPA退出时机

```c#
// 检查是否收敛 (新点距离面的距离非常小)
            LFloat supportDist = LVector3.Dot(searchDir, support);
            if (supportDist - closestFace.dist < LFloat.EPSILON) {
                // 收敛：穿透向量就是 dist * normal
                return closestFace.normal * supportDist;
            }
```

代码里我是这样写的，我们知道EPA是尝试去扩张一个多面体，让这个多面体尽可能的逼近闵可夫斯基差的多面体，在这个过程中找到距离原点最近的边界。

如果针对定点数棱角分明的两个碰撞体，这里的 <LFloat.EPSILON 的情况指的其实就是，**当我们发现，之前加入的**当前多面体的顶点，又被加入了，那说明真的已经找到最近的边界了

如果针对的是球，胶囊这种碰撞体，那这里的 <LFloat.EPSILON指的其实就是一种逼近，因为棱角分明的物体的顶点是有一个具体数的，但是球体这种，边界有无数个点，因此这里指的就是，我们每次查找的时候都找一个新的点加入，一直到加入新的点对于进一步逼近边界的作用不大，这时候就退出了。

## 基于冲量的解算器

> 你的疑惑很正常：教科书上的 **动量守恒公式** 是描述“结果”的（碰撞前=碰撞后），而代码里算的是一个叫 `j` (冲量) 的东西，看起来完全不一样。
>
> 但其实，**代码里的公式（冲量公式）正是由【动量守恒公式】+【能量恢复系数公式】联立推导出来的解。**
>
> 让我为你揭开这个推导过程，你会发现代码里的每一行都能和物理公式对应上。
>
> ------
>
> ### 1. 我们有两个物理定律
>
> 想要算出碰撞后的速度 $v_1'$ 和 $v_2'$，仅靠动量守恒是不够的（方程组解不出来），我们需要两个方程联立：
>
> #### 方程 A：动量守恒定律 
>
> $$m_1 v_1 + m_2 v_2 = m_1 v_1' + m_2 v_2'$$
>
> (这意味着：两人交换的动量必须相等，我给你多少，你就收多少，总量不变)
>
> #### 方程 B：牛顿恢复定律 (决定了弹不弹)
>
> $$(v_2' - v_1') \cdot n = -e \cdot ((v_2 - v_1) \cdot n)$$
>
> (这意味着：碰撞后的相对速度 = -e $\times$ 碰撞前的相对速度)
>
> - $n$ 是法线 = >EPA 算出的穿透向量归一化后就是法线
> - $e$ 是弹性系数 (`bounciness`)。
>
> ------
>
> ### 2. 把方程换个写法 (引入冲量 J)
>
> 直接解上面的方程组求 $v'$ 在代码里很麻烦。物理引擎通常使用 **冲量 (Impulse, $J$)** 来简化计算。
>
> 根据动量定理，速度的变化量等于冲量除以质量：
>
> - **物体 1 的新速度：** $v_1' = v_1 - \frac{J}{m_1} n$  (因为受到反作用力，方向为负)
> - **物体 2 的新速度：** $v_2' = v_2 + \frac{J}{m_2} n$  (方向为正)
>
> **注意：** 只要我们是用同一个 $J$ 给两个物体加减速度，**方程 A (动量守恒) 就已经自动满足了！** (因为加减抵消了)。
>
> 所以，我们现在的任务变成了：**求出这个 $J$ 到底是多少，才能满足方程 B (弹性)？**
>
> ------
>
> ### 3. 推导代码里的公式 (见证奇迹的时刻)
>
> 我们将上面 $v_1'$ 和 $v_2'$ 的表达式，代入到 **方程 B** 中：
>
> $$\left( (v_2 + \frac{J}{m_2}n) - (v_1 - \frac{J}{m_1}n) \right) \cdot n = -e (v_{rel})$$
>
> 这里 $v_{rel} = (v_2 - v_1) \cdot n$ (即代码里的 `velAlongNormal`)。
>
> 展开左边：
>
> $$(v_2 - v_1)\cdot n + J(\frac{1}{m_2} + \frac{1}{m_1}) = -e \cdot v_{rel}$$
>
> 把 $(v_2 - v_1)\cdot n$ 替换为 $v_{rel}$：
>
> 
>
> $$v_{rel} + J(\frac{1}{m_1} + \frac{1}{m_2}) = -e \cdot v_{rel}$$
>
> 移项，把 $J$ 留在左边：
>
> 
>
> $$J(\frac{1}{m_1} + \frac{1}{m_2}) = -e \cdot v_{rel} - v_{rel}$$
>
> $$J(\frac{1}{m_1} + \frac{1}{m_2}) = -(1 + e) \cdot v_{rel}$$
>
> 最终解出 J：
>
> 
>
> $$J = \frac{-(1 + e) \cdot v_{rel}}{ \frac{1}{m_1} + \frac{1}{m_2} }$$
>
> ------
>
> ### 4. 回看你的代码
>
> 现在，把最后推导出来的公式和你的代码对比一下：
>
> - **分子：** `-(1 + e) * velAlongNormal`
>   - 对应公式：$ -(1 + e) \cdot v_{rel} $
> - **分母：** `totalInvMass` (即 `a.InvMass + b.InvMass`)
>   - 对应公式：$ \frac{1}{m_1} + \frac{1}{m_2} $
> - **结果：** `LFloat j`
>   - 对应公式：$J$
>
> ```C#
> LFloat j = -(LFloat.one + e) * velAlongNormal / totalInvMass;
> ```
>
> ### 结论
>
> 你原本知道的公式 $m_{1}v_{1}+m_{2}v_{2}=m_{1}v_{1}^{\prime }+m_{2}v_{2}^{\prime }$ 是**宏观的守恒结果**。
>
> 而代码里的公式，是为了**构造**出这个结果，反向推导出的**微观操作步骤**（即：我到底要推多大力 $J$，才能既守恒，又符合弹性系数 $e$）。
>
> 所以，这段代码本质上就是**动量守恒定律的工程实现版**。