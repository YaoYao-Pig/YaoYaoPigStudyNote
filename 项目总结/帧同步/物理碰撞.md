# 物理碰撞



## 确定性保证：

先看俩，一个是确定的碰撞一个是碰撞结果不确定
![不确定碰撞](assets/不确定碰撞.gif)



![确定碰撞](assets/确定碰撞.gif)

为啥会这样的，下面几条总结

### 排序造成的问题

需要一个确定性排序

八叉树，EPA都会受到访问检测顺序的影响

### 回滚备份

为了保证这种确定性，必须要备份可物理交互物体的物理信息（看Interactive）



## EPA + 基于冲量的解算器



> 你的疑惑很正常：教科书上的 **动量守恒公式** 是描述“结果”的（碰撞前=碰撞后），而代码里算的是一个叫 `j` (冲量) 的东西，看起来完全不一样。
>
> 但其实，**代码里的公式（冲量公式）正是由【动量守恒公式】+【能量恢复系数公式】联立推导出来的解。**
>
> 让我为你揭开这个推导过程，你会发现代码里的每一行都能和物理公式对应上。
>
> ------
>
> ### 1. 我们有两个物理定律
>
> 想要算出碰撞后的速度 $v_1'$ 和 $v_2'$，仅靠动量守恒是不够的（方程组解不出来），我们需要两个方程联立：
>
> #### 方程 A：动量守恒定律 
>
> $$m_1 v_1 + m_2 v_2 = m_1 v_1' + m_2 v_2'$$
>
> (这意味着：两人交换的动量必须相等，我给你多少，你就收多少，总量不变)
>
> #### 方程 B：牛顿恢复定律 (决定了弹不弹)
>
> $$(v_2' - v_1') \cdot n = -e \cdot ((v_2 - v_1) \cdot n)$$
>
> (这意味着：碰撞后的相对速度 = -e $\times$ 碰撞前的相对速度)
>
> - $n$ 是法线 = >EPA 算出的穿透向量归一化后就是法线
> - $e$ 是弹性系数 (`bounciness`)。
>
> ------
>
> ### 2. 把方程换个写法 (引入冲量 J)
>
> 直接解上面的方程组求 $v'$ 在代码里很麻烦。物理引擎通常使用 **冲量 (Impulse, $J$)** 来简化计算。
>
> 根据动量定理，速度的变化量等于冲量除以质量：
>
> - **物体 1 的新速度：** $v_1' = v_1 - \frac{J}{m_1} n$  (因为受到反作用力，方向为负)
> - **物体 2 的新速度：** $v_2' = v_2 + \frac{J}{m_2} n$  (方向为正)
>
> **注意：** 只要我们是用同一个 $J$ 给两个物体加减速度，**方程 A (动量守恒) 就已经自动满足了！** (因为加减抵消了)。
>
> 所以，我们现在的任务变成了：**求出这个 $J$ 到底是多少，才能满足方程 B (弹性)？**
>
> ------
>
> ### 3. 推导代码里的公式 (见证奇迹的时刻)
>
> 我们将上面 $v_1'$ 和 $v_2'$ 的表达式，代入到 **方程 B** 中：
>
> $$\left( (v_2 + \frac{J}{m_2}n) - (v_1 - \frac{J}{m_1}n) \right) \cdot n = -e (v_{rel})$$
>
> 这里 $v_{rel} = (v_2 - v_1) \cdot n$ (即代码里的 `velAlongNormal`)。
>
> 展开左边：
>
> $$(v_2 - v_1)\cdot n + J(\frac{1}{m_2} + \frac{1}{m_1}) = -e \cdot v_{rel}$$
>
> 把 $(v_2 - v_1)\cdot n$ 替换为 $v_{rel}$：
>
> 
>
> $$v_{rel} + J(\frac{1}{m_1} + \frac{1}{m_2}) = -e \cdot v_{rel}$$
>
> 移项，把 $J$ 留在左边：
>
> 
>
> $$J(\frac{1}{m_1} + \frac{1}{m_2}) = -e \cdot v_{rel} - v_{rel}$$
>
> $$J(\frac{1}{m_1} + \frac{1}{m_2}) = -(1 + e) \cdot v_{rel}$$
>
> 最终解出 J：
>
> 
>
> $$J = \frac{-(1 + e) \cdot v_{rel}}{ \frac{1}{m_1} + \frac{1}{m_2} }$$
>
> ------
>
> ### 4. 回看你的代码
>
> 现在，把最后推导出来的公式和你的代码对比一下：
>
> - **分子：** `-(1 + e) * velAlongNormal`
>   - 对应公式：$ -(1 + e) \cdot v_{rel} $
> - **分母：** `totalInvMass` (即 `a.InvMass + b.InvMass`)
>   - 对应公式：$ \frac{1}{m_1} + \frac{1}{m_2} $
> - **结果：** `LFloat j`
>   - 对应公式：$J$
>
> ```C#
> LFloat j = -(LFloat.one + e) * velAlongNormal / totalInvMass;
> ```
>
> ### 结论
>
> 你原本知道的公式 $m_{1}v_{1}+m_{2}v_{2}=m_{1}v_{1}^{\prime }+m_{2}v_{2}^{\prime }$ 是**宏观的守恒结果**。
>
> 而代码里的公式，是为了**构造**出这个结果，反向推导出的**微观操作步骤**（即：我到底要推多大力 $J$，才能既守恒，又符合弹性系数 $e$）。
>
> 所以，这段代码本质上就是**动量守恒定律的工程实现版**。