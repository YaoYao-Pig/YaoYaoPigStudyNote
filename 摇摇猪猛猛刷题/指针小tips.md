## 链表中点：

划分链表考虑快慢指针，但是要注意，快指针初始状态应该指向head->next，而慢指针可以直接指向head

```c++
ListNode* fast = head->next, *slow = head;
```

的关键是：**确保在链表长度为2时也能正确拆分成两部分**，避免无限递归或不必要的额外分支判断。

###  为什么 `fast` 指向 `head->next` 而不是 `head`？

#### ✅ 使用 `fast = head->next` 的结果：

- 链表长度为2时，`slow` 停在第一个节点（`head`），`slow->next` 是第二个节点。
- 然后我们断开 `slow->next = nullptr`，链表被成功分成两个节点：head 和 tmp。

#### ❌ 如果你使用 `fast = head`：

- 对于两个节点的情况：

  - 初始时 `fast == head`，`slow == head`。
  - 循环时 `fast->next && fast->next->next` 不成立（因为 `fast->next->next == nullptr`）。
  - 所以 `slow` 仍然停在第一个节点。
  - 你会得到相同的断开位置，看起来没问题……

  但对于**多个节点（3个以上）时**，这会影响**中点位置的选择**，从而影响递归深度和平衡程度，甚至可能影响效率。

------

###  总结：

使用：

```
ListNode* fast = head->next, *slow = head;
```

的优点是：

- 对于偶数个节点，`slow` 会停在“中间偏前”的那个节点，有利于 **分成尽可能平衡的两半**。
- 避免进入死循环或错误分段（特别是链表长度为2的边界情况）。
- 更贴近标准的链表中点查找写法（用于拆分）。