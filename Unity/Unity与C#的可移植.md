# Unity与C#的可移植性

## **C# 的编译与运行过程**

C# 的编译和运行过程是一个分阶段的流程，从源代码的编译到最终程序的执行，经历了多个步骤。以下是结合运行时环境的完整编译运行过程：

```
C# 源代码 (.cs)
        ↓ 编译器 (csc/Roslyn)
IL 文件 (.exe/.dll, 包含 IL + 元数据)
        ↓ 运行时 (Mono/.NET Core/CLR)
即时编译 (JIT) 或 预编译 (AOT)
        ↓
目标平台的机器码
        ↓
程序执行 (内存管理 + 平台适配 + 安全监控)
```



------

###  1. C#源代码

```c#
class Program {
    static void Main() {
        Console.WriteLine("Hello, World!");
    }
}
```

------

### **2. 编译阶段**

使用 C# 编译器（例如 `csc` 或 `Roslyn`）将 C# 源代码编译为中间语言（IL，Intermediate Language）：

- 源代码被解析成抽象语法树（AST）。

- 检查语法和类型错误。

- 生成 

  ```
  .dll
  ```

  （动态链接库）或 

  ```
  .exe
  ```

   这些文件中包含：**中间语言（IL）**：与具体硬件无关的指令集。和**元数据**：描述类型、方法、属性的信息。

**结果文件**：

- 程序被编译为可供运行时执行的 IL 文件，例如：HelloWorld.exe (含 IL 和元数据)

### **3. 加载到运行时**

编译后的 `.exe` 或 `.dll` 文件由运行时（如 Mono 或 .NET Core）加载并准备执行。

运行时负责：

- 读取 IL 和元数据。
- 准备运行环境，例如加载库和初始化对象。

### **4. 转换 IL 为机器码**

运行时通过以下方式将中间语言（IL）转为目标平台的机器码：

#### **即时编译（JIT，Just-In-Time Compilation）**

- 当程序执行到某段代码时，运行时将对应的 IL 转译为机器码。
- JIT 的优点是可以根据目标设备的硬件特性生成优化的代码，但启动时可能有额外的延迟。

#### **预先编译（AOT，Ahead-Of-Time Compilation）**

- 在程序运行之前，将整个 IL 编译为目标平台的机器码。
- 常见于移动平台（如 Unity 使用 IL2CPP 技术将 IL 转为 C++ 代码，然后编译为原生代码）。
- 但是有一部分例如trampolines或者管控监督相关的代码依然需要JIT运行

**完全静态编译**

+ 这种模式只支持少数平台，它完全预先生成所有机器码，在程序运行中完全不需要使用JIT，这个做法适用于IOS，PS3以及XBOX360等不允许使用JIT的平台。

> Unity在打包时，如果目标是iOS，那么用的是完全静态编译，如果是Windows或者Android，那么使用的是JIT

**IL 的示例（类似汇编语言）**：

```
IL_0000: ldstr "Hello, World!"
IL_0005: call void [mscorlib]System.Console::WriteLine(string)
IL_000A: ret
```

### **5. 执行程序**

运行时负责执行最终生成的机器码，并管理程序运行期间的核心功能：

#### **内存管理**

- 分配和释放内存。
- 使用垃圾回收（GC）回收不再使用的内存，减少内存泄漏。

#### **平台适配**

- 屏蔽操作系统差异，提供统一的 API。
- 跨平台运行的能力（如同一代码在 Windows、Linux 和 macOS 上运行）。

#### **运行时优化**

- JIT 编译器可能会进行 **运行时优化**，如内联函数、消除冗余代码等。

### **6. 程序终止**

- 程序完成逻辑后终止，释放所有资源。
- 运行时通知操作系统结束任务。

## **内存管理**、**平台适配** 和 **安全监控**

> 程序执行时的 **内存管理**、**平台适配** 和 **安全监控**，这些关键任务是由运行时（Runtime）来控制和管理的。

### **1. 内存管理**

运行时负责管理程序的内存分配和释放，主要通过以下机制：

#### **垃圾回收（GC, Garbage Collection）**

- **自动内存分配**：当程序创建对象时，运行时会在堆内存中分配空间。

- 释放不再使用的内存

  ：运行时通过垃圾回收器检测哪些对象不再被引用，并回收这些对象占用的内存。

  - 避免手动管理内存导致的内存泄漏或错误释放（常见于 C/C++ 程序）。
  - **GC 的优化**：如分代垃圾回收（Generation-based GC），提升了内存管理效率。

**控制范围：**

- 程序无需显式释放内存，运行时全权负责。
- 运行时可能触发 GC 时会引发性能抖动，因此开发者需要优化内存分配频率。

------

### **2. 平台适配**

运行时封装了底层的操作系统差异，让程序在不同平台上运行时的行为保持一致。

#### **跨平台执行**

- **抽象操作系统接口**：运行时通过标准化的 API（如文件 I/O、线程、网络）对接底层操作系统，不同平台的实现由运行时处理。
- **屏蔽硬件差异**：运行时适配 CPU 架构（如 x86、x64、ARM）和硬件特性（如 SIMD 指令集）。

#### **示例**

- 在不同系统上调用文件操作：
  - **Windows** 使用 WinAPI（如 `CreateFile`）。
  - **Linux** 使用 POSIX（如 `open`）。
  - **开发者无需关心差异**，运行时统一处理。

**控制范围：**

- 运行时提供统一的 API 层，让开发者的代码独立于具体平台。
- Unity 中的 C# 程序在 Windows、iOS 和 Android 上可以通过 Mono 或 IL2CPP 达到一致的行为。

------

### **3. 安全监控**

运行时提供了一系列安全机制，确保程序在运行时的安全性，包括：

#### **代码验证**

- 运行时会检查加载的中间语言（IL）是否符合安全要求（如类型安全）。
- 防止执行未经授权的代码或恶意代码。

#### **沙箱机制**

- 在特定场景下（如 Web 应用），运行时将限制代码访问系统资源的权限，保护主机安全。

#### **异常处理**

- 运行时捕获未处理的异常，避免程序崩溃。
- 通过统一的异常机制（如 `try-catch`），开发者能够优雅地应对错误。

#### **动态权限管理**

- 针对特定操作（如文件读写、网络访问），运行时会检查程序是否具备必要权限。

**控制范围：**

- 程序运行时的每一步操作都会受到运行时的监控，确保代码行为符合预期。

## Mono与IL2CPP

Mono是.Net FrameWork的一个运行时。最初的.Net FrameWork只支持Win平台，因此为了支持真正的多平台，所以有了开源项目Mono。现在的.Net Core也支持多平台，并且Unity也在转向对于.Net Core。

但是Mono也有局限，Mono的流程在JIT的时候，是先把源代码处理为IL，然后运行时再翻译为机器码。而Mono的AOT则是先翻译为机器码再运行。

Mono自身存在一定的问题：

**有限优化**：Mono 的 AOT 编译只对 IL 做了基础的转换，缺乏高效优化的机制，比如函数内联、指令集优化等。

**依赖解释器**：Mono 的 AOT 编译有时仍需要运行时解释器辅助，尤其是处理一些动态代码（如泛型）。

- 这会引入性能损失，而 IL2CPP 可以完全绕过解释器。

所以Unity开发了一种代码转换和编译技术。它并非对 Mono 的改进，而是 Unity 针对性能优化和平台适配问题，**完全独立于 Mono** 开发的一套工具链，用于替代 Mono 或其他运行时环境在部分场景下的功能。

**IL2CPP 是一个代码转换工具链**，其作用是将 C# 编译后的中间语言（IL）代码转换为 C++ 代码，再通过目标平台的 C++ 编译器生成原生机器码。

IL2CPP依然需要运行时的支持，他不提供比如标准库的封装或者GC等功能，需要依赖比如Mono等运行时的支持