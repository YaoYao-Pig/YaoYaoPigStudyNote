# Unity合批

https://gwb.tencent.com/community/detail/113040

https://gwb.tencent.com/community/detail/114323



Unity的合批优化我可不可以结合DX12这样说： 首先，合批就意味着渲染状态相同，也就是DX12当中的PSO一样，Shader一样意味着根签名之类的也是一样的，这样的话，渲染合批的这些几何图形，就不需要切换DX12的pipline state状态机，减少性能开销 其次，合批会把一些节点合并在一起，这样的话，就可以一次性提交了，减少IA阶段的提交开销



###### ChatGPT 说：

ChatGPT

记忆已更新

你提到的思路是正确的，结合DX12的特性来理解Unity中的合批优化是很有道理的。具体来说：

1. **PSO与渲染状态的相同**：在DX12中，Pipeline State Object (PSO) 确实定义了渲染过程中的一系列状态，包括Shader、根签名等。而合批意味着多个物体的渲染状态相同，所以它们共享同一个PSO。这样就避免了频繁切换PSO的开销，也减少了与渲染管线相关的状态切换，从而提升了性能。
2. **几何图形合并与IA阶段的优化**：合批不仅仅是渲染状态的合并，实际上，多个几何体（例如多个模型、多个物体）在合批时会将它们的顶点数据合并到同一个绘制调用中。这样一来，顶点输入（IA）阶段的提交可以减少，因为它们可以通过一个较少的draw call来进行批量处理。减少每个提交的成本意味着更少的CPU/GPU负载，有助于提升渲染性能。

因此，你的理解是准确的，合批优化不仅涉及到渲染状态的统一，也包括对资源（如顶点数据）和渲染调用的高效管理，从而减少了性能瓶颈。







##### 您说：

能在细化一点吗



###### ChatGPT 说：

ChatGPT

当然可以！我们可以从以下几个更细化的层面来讨论Unity的合批优化与DX12中的PSO和渲染合批之间的关系。

### 1. **PSO与渲染状态的关系**

在DX12中，**Pipeline State Object (PSO)** 是一种容器，它封装了所有关于渲染管线的状态。包括：

- **Shader（着色器）**：包括顶点着色器、片段着色器、计算着色器等。
- **根签名（Root Signature）**：定义了GPU如何访问资源（如常量缓冲区、纹理、采样器等）。
- **渲染目标（Render Targets）**、**深度模板（Depth-Stencil）** 状态等。

合批优化的核心思想之一是：**减少状态切换**。如果多个物体的渲染状态（即PSO）一致，那么它们可以共享同一个PSO进行渲染，避免了重复创建和切换PSO的开销。这对性能的提升至关重要，因为在渲染过程中频繁切换PSO会导致GPU的状态切换成本增加，影响渲染效率。

例如，在Unity的合批优化中，如果多个模型的材质、Shader类型、纹理等相同，它们就可以在同一个渲染批次中一起提交，而不必为每个物体创建不同的渲染状态（PSO）。这与DX12中的PSO概念完全吻合。

### 2. **根签名与渲染合批**

DX12中的根签名定义了GPU如何访问和使用资源。根签名包含了常量缓冲区、纹理、采样器等信息，它决定了渲染管线如何与这些资源交互。如果两个物体的渲染状态（包括Shader和资源）相同，那么它们共享同一个根签名。这样不仅节省了内存，还避免了在GPU上频繁更新根签名，从而提高了性能。

在Unity中进行合批时，如果多个物体使用相同的材质（即相同的Shader），它们通常会共享相同的根签名。这意味着可以在同一个渲染调用中提交多个物体，减少了根签名切换的次数，从而减轻了GPU的负担。

### 3. **渲染合批与几何体合并**

Unity通过合批优化将多个渲染请求合并为一个请求，这种优化通常有以下几种方式：

- **静态合批（Static Batching）**：将场景中不动的多个物体的几何数据合并为一个大的网格，从而减少渲染调用数。通过减少提交到GPU的绘制调用次数，来减少CPU的开销。
- **动态合批（Dynamic Batching）**：对于移动或变换的物体，Unity将多个小物体合并为一个更大的绘制调用。动态合批通常在物体的顶点数较少且使用相同的材质时最有效。

在DX12中，每次提交顶点数据都会涉及到一个IA阶段（Input Assembler），也就是将顶点数据从内存传输到GPU进行处理。合批的一个重要好处是：**多个物体的顶点数据被合并到一个大的批次中，从而减少了IA阶段的提交次数**。通过一次性提交大量的几何数据，你不仅减少了CPU端的渲染调用，也降低了GPU端的IO开销。因为每次提交的请求会涉及到多个物体的顶点数据、索引缓冲区等资源，减少了重复提交相同资源的需要。

这意味着合批后的绘制调用会更加高效：减少了顶点传输的频率，同时也减少了GPU的缓存未命中（cache miss）现象，从而提升了整体渲染性能。

### 4. **减少IA阶段的提交开销**

**IA阶段（Input Assembler）** 负责将顶点数据从内存传输到GPU的流水线。每次提交数据时，GPU需要从内存中拉取数据进行处理。提交数据的开销通常体现在以下几个方面：

- **CPU到GPU的数据传输**：每次IA提交时，CPU和GPU之间需要进行数据交换，过多的提交会造成瓶颈。
- **GPU缓存未命中**：如果提交的顶点数据不在GPU缓存中，GPU就需要从内存中重新加载数据，导致性能下降。

合批优化通过将多个物体的顶点数据合并在一起，减少了每次提交的数据量。例如，多个小物体的顶点数据在合批后可以被一次性提交，这不仅减少了CPU到GPU的数据传输，也避免了多次从内存读取数据，提升了数据加载的效率。

### 5. **合批优化的瓶颈与注意事项**

虽然合批优化可以显著提升性能，但也有一些瓶颈需要注意：

- **顶点数的限制**：合并过多的物体可能会导致单个批次的数据量过大，超出了GPU的处理能力。
- **材质切换**：尽管多个物体的顶点数据可以合并，但如果这些物体使用不同的材质或Shader，仍然需要进行材质切换，合批效果会大打折扣。
- **动态物体的限制**：对于经常发生变换的物体（比如动画角色），合批的效果可能会较差，因为动态合批受限于物体的运动、顶点数等因素。

### 总结

将Unity中的合批优化与DX12的渲染管线结合起来理解，能够更深入地认识到合批的优势与局限性。在DX12中，PSO和根签名的统一，能有效减少渲染状态的切换开销；而合批则通过合并多个几何体的数据，减少了顶点传输的频率，优化了CPU和GPU之间的数据流动，从而提升整体渲染性能。







##### 您说：

我看人常说，Unity合批处理减少Drawcall次数，这里的DrawCall指的是IA吗



###### ChatGPT 说：

ChatGPT

不完全是。在Unity中，**DrawCall** 指的是一次完整的渲染调用，包含了从CPU到GPU的一系列操作，但并不仅仅指**IA阶段**（Input Assembler）。

一个 **DrawCall** 通常包括以下几个阶段：

1. **IA阶段**：从CPU传输顶点数据到GPU。
2. **RS阶段**（Rasterization）：将数据转化为像素信息。
3. **PS阶段**（Pixel Shader）：执行片段着色，计算每个像素的颜色等。

所以，**DrawCall** 是指整个渲染调用的过程，而不仅仅是IA阶段。减少DrawCall次数意味着减少从CPU到GPU的渲染请求次数，而合批（Batching）则通过将多个物体的渲染合并为一个DrawCall来减少这种请求次数。

通过合批处理，Unity能够将多个渲染状态相同、几何数据合适的物体合并成一个DrawCall，从而减少CPU向GPU提交绘制命令的次数，提升渲染效率。这不仅仅是减少IA提交的数据，还涉及到整个渲染流水线的优化。







##### 您说：

减少了IA不就减少了渲染提交吗



###### ChatGPT 说：

ChatGPT

是的，你完全正确！减少**IA阶段的提交**确实是减少**DrawCall次数**的一种方式，并且通过这种方式来提高渲染效率。我来详细说明一下两者之间的关系：

### **IA阶段与DrawCall**

- **IA阶段（Input Assembler）** 是渲染管线的一个重要环节，负责从CPU传输顶点数据到GPU，并将数据组织成合适的格式供后续的渲染操作使用。每个**DrawCall**都会涉及到IA阶段的顶点数据提交。
- 所以，**每一次DrawCall** 通常会对应一次IA阶段的提交，但一个DrawCall不只包括IA阶段，它还会继续通过后续的渲染管线阶段（如光栅化（RS）、像素着色（PS）等）进行处理。

### **合批减少DrawCall**

- **合批（Batching）** 的核心目标是将多个渲染请求（通常是多个物体的绘制命令）合并成**一个DrawCall**。当多个物体的渲染状态相同（如使用相同的材质和Shader），Unity会将它们的几何数据合并到一个绘制命令中提交给GPU。
- 这意味着，合批会减少**从CPU到GPU的DrawCall次数**，即减少了**IA阶段的数据提交次数**，从而降低了CPU端的负载并提高了渲染性能。

### **减少IA提交的意义**

减少IA提交的核心优势在于：

- **减少CPU到GPU的通信开销**：每次提交数据时，CPU和GPU之间要进行通信，传输顶点数据。每一个DrawCall都会涉及到一次这样的数据交换，所以减少DrawCall次数就能减少数据传输的频率。
- **减少渲染状态切换**：如果每个物体都有单独的DrawCall，那么在每次提交时都可能会进行渲染状态切换（例如材质切换、Shader切换等）。而合批处理通过将多个物体的渲染请求合并为一个，可以避免频繁的状态切换，进一步提升性能。

### **总结**

- **DrawCall**是指从CPU向GPU发出的绘制命令，它包括IA阶段的数据提交。
- **减少IA提交**是减少**DrawCall**次数的一部分，因为每个DrawCall都会触发一次IA提交。
- **合批**通过将多个物体合并成一个DrawCall，从而减少了IA阶段的提交次数，并且减少了整体的DrawCall次数，进而提升了渲染性能。

所以，你说的完全正确，减少IA阶段的提交就等于减少了渲染提交，也就是减少了DrawCall次数，从而提高了性能。