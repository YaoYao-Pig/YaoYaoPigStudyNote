# 左值、右值、std::move与移动语义

glvalue、xvalue、prvalue

> 右值其实是一种“约定”，约定一种权限的转移，并且约定之后原来的事物就要消亡，就是约定“浅拷贝”。
>
> 常用在原本深拷贝的时候，现在换成move，原来深拷贝要分配内存，拷贝每一个指针指向的对象。但是换成move之后，直接把指针赋值，就可以了
>
> 移动构造需要“右值引用”而不是“右值
>
> 比如对于一个类A，A()会触发拷贝构造，但是std::move(A())会触发移动构造，因此即使是右值，也需要std::forward来将它转换为右值引用，来触发移动构造
>
> 看这个例子：
>
> int && a=10;
>
> a的类型是右值引用，但是a本身是个左值，因此对于如下的两个函数重载：
>
> void process(int& *x*) {
>
>   std::cout << "l: " << *x* << std::endl;
>
> }
>
> void process(int&& *x*) {
>
>   std::cout << "r: " << *x* << std::endl;
>
> }
>
> process(a)匹配的是左值版本

这样让我们再来理解完美转发：

```cpp
template <typename T>
class Wrapper {
public:
    T value;

    // 完美转发构造函数
    template <typename U>
    Wrapper(U&& arg) : value(std::forward<U>(arg)) {}  // 使用 std::forward 来完美转发
};
// Wrapper(U&& arg) : value(arg) {}  // 不使用 std::forward 来完美转发
```

如果不使用完美转发，那么无论arg传入到时候是左值还是右值，(也即无论是`Wrapper(A())，还是A a; Wrapper(a)`)，arg本身都是一个左值，只是因为万能引用的存在，让arg的`类型`一个是右值引用，一个是左值引用。但是本身都是左值。而根据其自身都是左值，因此只会调用拷贝构造。

但是如果使用了完美转发，就会根据其自身的*类型*，将它转换为对应的类型

## 拷贝与移动

我们先来考虑拷贝和移动的区别。

我们知道，在C++当中，绝大多数的内置或者自定义类型都是支持“拷贝”语义的。

```c++
int a=1,b=0;
b=a;
A a;
A b;
b=a;
```

拷贝的具体行为其实就是“复制”，将某个对象或者数值复制一遍，然后赋给新的对象的过程。在完成拷贝之后，我们从逻辑上是希望拷贝行为产生了”两个新的从内容上完全一样的对象“——首先他们是两个不同的对象（在地址上），但是从内容上，二者是一致的。

然而，当我们仔细考虑C++或者现实生活中的一些行为时，我们会发现，很多时候我们需要的是”转移“这个行为。

看以下示例：

```c++
void swap(A* a,A* b){
	A tmp=*a;
	*a=*b;
	*b=*tmp;
}
```

在上述swap语句当中，我们在swap时，需要一个中间量tmp作为临时存储。在这时，我们使用了拷贝运算符（tmp=a）也就是拷贝语义。然而我们仔细考察一下上述逻辑。首先我们将a的数值复制给tmp，然后用b的内容覆盖了a，最后我们用tmp的内容赋值给b。在这个过程中，当我们将a的数值赋值给tmp之后，我们事实上就已经不在使用a的原始值了。换句话说，**A tmp=*a;**之后，a对象的原始内容，就没有意义了。

如果我们自己考虑swap语句的行为，我们会发现，实际上，swap并不是希望一个”复制“的语义，而是希望一个“转移”的语义，也就是将a的内容“转移”到tmp当中，将b的内容转移到a当中，最后再将tmp的内容转移给b。在这个过程中发生的是“左手倒右手”。

其实，这与现实世界的逻辑是一致的，在现实世界，我们大部分情况下发生的并不是一个事物的复制，而是**所有权的转移**。改进后的swap:

```
void change_owner(A* a,A* b){...}//某个交换所有权的函数,可以把b的所有权转移给a
void swap(A* a,A* b){
    change_owner(tmp,a);
    change_owner(a,b);
    change_owner(b,tmp);
}
```

现在，我们在拷贝的基础上引入了移动的概念。

我知道，大家一定会在像，搞这么麻烦，有啥意义吗，请大家先带着这个疑问，我们会在后面逐渐的介绍清楚。

## 何为左值、右值

从定义上讲，左值右值的划分是比较混乱的，有很多种说法。对于一个存储在计算机当中的数据实体来说，它一般有两个主要部分组成，一个是存储的内容，另一个获取它的“句柄”（handle）或者说，名字、身份。在这个基础上，一个比较规范的的说法是，左值**指的就是这种有身份的对象**，而右值就是不能作为左值的值。

或者更加准确一些，对于一个对象而言，我们通常会进行这些操作：寻址、拷贝、赋值、移动等。而对于这些操作，有两个属性是非常重要的：有身份和可移动。

对于一般定义下的左值来说，它应当是“有身份且不可移动的”，而对于右值来说，它应当是“无身份且不可移动的”。

还有一种说法是，左值就是在内存当中的值，右值就是在寄存器里的临时值。

------

我个人觉得，从行为上来理解左值和右值是更加准确的。

左值是一种有身份的值，所谓的身份，就是名字，地址（指针）等。我们可以通过这种身份——或者句柄——来获取到对象的具体内容。这里隐藏了一个行为，就是对于一个有身份的值来说，只要我还记得他的身份，我就可以一直找到他并且对他操作，也就是，对于左值的行为需要是一种保护性质的。

而右值则是那些”没有身份的”值。（后面我们会知道这其实并没有那么准确）。没有身份就意味着，当我们离开当前的语句之后，我们就没有办法拿到右值了。这里隐含的行为是，右值意味着，当我们“用完”他一次之后，就不在需要它了，换言之，对与右值的操作可以是一种破坏性的。

```c++
int i=10;//i左值，通过i可以反复获取
10，“10”//都是右值，第一句里面的10也是右值。离开了之后我们就获取不到这个10了。
```

现在，让我们综合“拷贝与移动”和“左值右值”。

非常显然的是，保护性操作的左值，对应的就是拷贝行为，因为拷贝行为并不会是我们“失去”或者“破坏”对于初始值的掌握。而破坏操作的右值对应的则是移动行为，在移动的过程中我们毫无疑问发生了“所有权的转移”或者“失去了对于初始对象的操作能力。

## 右值与移动语义

右值就是那种之后用不到的值。

对于一个类型来说，可以构建“移动构造函数”和“移动赋值运算符”，与拷贝构造函数和拷贝赋值运算符一样，当对右值进行相应的操作时，就会调用对应移动操作。

```c++
class A{
    A(){...} //默认构造函数
 	A(A& a){...}//拷贝构造函数
    A(A&& a){...}//移动构造函数
 	A& operator(A&& a)={...}//移动赋值运算符
};
```

用法：

```c++
A a; //默认构造函数
A b=a;//等同于；Ab(a);因为a是左值，并且b是在初始化，因此调用的是拷贝构造函数
A c=static_cast<A&&>(a);//a是左值，经过static_cast转换之后变为A&&右值，调用的是移动构造函数。
A d; //默认构造函数
d=A();//A()会调用默认构造函数，然后赋值过程调用移动赋值运算符
```

这里要注意static_cast<T&&>()，在具体使用的时候，static_cast很麻烦，所以C++提供了std::move函数。

std::move其实就是对static_cast<T&&>()封装了一层：

```c++
template <class _Ty> 
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```

但是这小小的一个函数，真的很复杂。

## std::move()

std::move是对于static_cast的封装，简单来说，它完成了将一个值转换为右值的行为。

有的同学可能会奇怪，我们有左右值不就得了，为什么还需要一个转换的函数？因为，将左值变成右值，才是我们最常用的场景：

```c++
vector<A> v;
A a();
//..做了很多操作..
v.push_back(a);
```

我们对a做完了基本的初始化之后，就不太再会对a进行处理了，而是将它”放进“了v当中，之后我们操作的时候，不再会对a进行操作了，而是会对v当中存储a的那个位置进行操作。所以push_back这个过程，我们其实是希望它进行”移动“操作的。但是a毫无疑问是左值。那么就需要一个方法把它转换为右值，也就是上文提到的std::move了。



------



```C++
template <class _Ty> 
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```

|                                                  |        |
| ------------------------------------------------ | ------ |
| `_NODISCARD constexpr remove_reference_t<_Ty>&&` | 返回值 |
| `move`                                           | 函数名 |
| `_Ty&& _Arg`                                     | 形参   |

我们先不看std::move的具体内容，我们来思考一个这样的问题，从实践上来说，我们希望std::move可以接收什么样的参数？

首先我们一定希望他可以接收右值，因为右值转换为右值实在是太合理不过了，对于一个右值，就应该输出其自身。

那么左值呢？或者说，如果不能接收左值，那么这个函数的使用就太受限制了吧。将左值转换为右值，应该是move函数最应该做到也是我们最希望它可以做到的。因此，我们一定是希望函数可以作用在左值也可以作用在右值。那么如何实现呢？

函数重载，对的没错，但是我们去看标准库我们会发现，C++似乎并没有提供第二种std::move的实现。

那就只有一种可能了！形参有玄机！

也就是`_Ty&& _Arg`可以接收左值和右值！

这怎么可能！一个参数怎么可能对应两种数值类型！但是C++通过复杂的机制真的做到了这件事情（真的很复杂），形如T&&的技术被称为**通用引用**。要想弄明白通用引用的原理，我们要从类型推导开始。

## 类型推导

大家知道，在C++当中，我们是可以使用模板的。也就是形如：

```c++
template<class T>
void func(T a){...}
```

这是多态机制的重要组成部分。实际上模板就是在做”类型推导“，而C++种同样也有一种类型推导技术，那就是auto

```c++
auto i=1;
```

实际上，auto的机制和T的机制是非常类似的，因此下文我们会把这二者一起用来举例。



------



初学C++的时候，我觉得类型推导很简单，我调用的时候是什么类型那就推导为什么类型就型了呗。但是，现实情况情况是很复杂的，C++为类型推导制定了复杂的推导规则，碍于行文连贯性，我这里只能简单介绍一下（其实是我也不是很懂QAQ）。

### 类型剥除（stripping）

形如`auto a ={expression}`的语句，auto的类型是什么呢？我觉得大部分人一定都会不假思索：{expression}是啥就是啥呗？确实，在很多情况下确实是如此的，但是有一些情况就会有所不同，看以下例子：

```c++
template<class T>
void func(T t){...}
int main(){
	int i;
	const int j;
	const int& k;
    const int&& l;
	func(i);
	func(j);
	func(k);
    func(l);
}
```

现在请考虑，`func(i),func(j),func(k),func(l)`当中，T的类型是什么？

对于`func(i)`来说，那T一定是`int`对吧。但是对于`func(j)`来说，T是`const int`吗？实际上并不是的，T的类型是int，const被剥除（stripping）了。而对于`func(k)`来说，T不是`const int&`而是`int`。`func(l)`也是一样的，右值修饰和const都被剥离，T的类型为int。

这实际上可能有点反直觉，但是非常符合使用的要求，func函数内部可能是会需要使用T这个类型来进行其他的操作，如果我们将T推导为const int或者const in&，那么泛型的灵活性会大大降低。并且对于const这些修饰符来说，它本质上就只是一种”约定“，将T推导时剥除具体的修饰符，而将它变为修饰前的类型（比如int），那么在函数的行为上是不会破坏这种约定的（因为函数的形参变成了一个拷贝行为）。

有一种情况是例外的，没错，就是我们亲爱的指针。

对于一个形如`const T* p`的low-level的const修饰的指针来说（底层const），情况就有所不同，`const T`的意思是，指针所指向的内存是不可以被修改的，而不是指针本身不可以被修改，因此如果这时候T的推导结果只是int*的话，函数内部就可以绕过const对指针指向的只读内存进行修改了，这是不可接受的。因此对于low-level const修饰的指针来说，T的类型会被推导为`const T*`。

------

实际上，C++是希望使用者自行控制在类型推导行为当中的修饰符的。

以const为例子，同时我们自行控制修饰符和左右值，会有四种类型的组合：

>T&
>
>T&&
>
>const T&
>
>const T&&

在开始之前，请大家记住，**剥离也好，推导也罢，都是对于T的，而不是对于整个类型**

### constT& 和const T&&

我们调换一下顺序，先讨论最简单的两种情况，那就是修饰符加满了。我们指定好了const和左右值引用，这种情况最简单。

对于`const T& a1={expression}`来说，a1最后就是一个根据expression推导出来的左值引用。而对于`const T&& a2={expression}`最后a2的类型也会是一个根据expression推导出来的右值引用。

这里要指出的是，const T&其实它可以不止指向一个左值，如果指向一个右值的话，其实相当于指向了一个临时对象（当然这种行为并不好）。再插一嘴，比如const int&，甚至可以指向非int类型的右值，语法，很神奇吧。

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="https://raw.githubusercontent.com/YaoYao-Pig/YaoYaoZhu-Pic/main/image-20240709103553297.png"
         alt="无法显示图片时显示的文字"
         style="zoom:这里写图片的缩放百分比"/>
    <br>		<!--换行-->
    《C++程序语言设计.第1-3部分 4th》7.7.1	<!--标题-->
    </center>
</div>

### T&

```c++
auto& a={expression};
```

当我们限定了类型最终的结果会是一个左值的时候，对于T推导的剥离就会发生变化，因为无论T是什么，最后我们都希望a的类型是一个左值引用，因此，如果expression是一个左值引用的话，那么T或者auto的引用是可以剥离的。

但如果expression是一个const呢？

```c++
const int i=0;
const int& j=i;
auto& a=j;
```

如果auto推导的结果剥离了const，那么a的类型就是`int&`，这就会成为一个绑定在const左值引用上的非const左值引用，我们就可以通过a去修改j的所指。这显然是不行的（考虑为什么`auto a=j`就可以剥离呢？因为同时剥离了修饰符和&，a的类型就是一个基本类型，不会对访问权限造成影响，除了指针）。因此auto推导的结果就是：const int。也因此，对于形如`auto& a={expression};`的推导式，**会剥离左值引用，但不会剥离const等修饰符。**

### T&&

终于来到了我们的主题，还记吗，我们在std::move一节最后的那个问题：关于T&&的通用引用。（忘记的可以回去看看）

T&&的规则更复杂了，但是也还好，只需要记住一句话：对于形如`auto&& a={expression};`的类型推导，{expression}只用来推导*修饰符*，auto的引用符号的推导，只看{expression}是左值还是右值。

+ 修饰符号：如果{expression}是const修饰的左值，那么const无法剥除；如果{expression}是const修饰的右值（const右值是什么东西，本身就无法修改，无意义），const需要剥除
+ 引用符号：如果{expression}是T类型的左值，那么auto类型为T&，如果{expression}为T类型的右值，那么auto类型为T。

让我们来看几个例子：

```c++
int i=0;
auto&& a1=i; //i是左值，所以auto类型为int& ，a1类型为int& &&
const int& j=i;
auto&& a2=j;//j是左值，因此const无法剥除，所以auto类型为const int&，a2类型为const int& &&
auto&& a3=10;//10是右值，auto为int&&，a3类型为int&& &&
```

我们已经推导出了上面几个例子的auto和对象的类型，但是问题没有结束。

**`int& &&`、`int&& &&`**是什么东西啊！

众所周知，C++是不允许引用的引用，上述的这一大串引用符号，显然就是引用的引用。但是C++其实是不允许我们自己写的引用的引用，在编译的过程中，推导产生的引用的引用时合法的。但是当产生这样引用的引用的时候，C++就会触发另一个机制，**引用折叠**（真的好复杂QAQ)

#### 引用折叠

引用折叠一共有四种情况：

```
1.T&& &&
2.T&& &
3.T& &&
4.T& &
```

对于这四种情况，**引用折叠说到底很简单，就一句话：右值的右值引用折叠为右值引用（对应第一种情况），左值的任何情况都折叠为左值引用。（剩下三种情况）**

现在我们再来看上述例子：

```c++
int i=0;
auto&& a1=i; //i是左值，所以auto类型为int& ，a1类型为int& &&；触发引用折叠，a1类型为int&
const int& j=i;
auto&& a2=j;//j是左值，因此const无法剥除，所以auto类型为const int&，a2类型为const int& &&;触发引用折叠，
																					//a2类型为const int&
auto&& a3=10;//10是右值，auto为int&&，a3类型为int&& &&;触发引用折叠，a3类型为int&&
```

## 通用引用：T&&

好，到这里我们终于铺垫完了，我们再回来考察T&&为什么是所谓的”通用引用“。

对于`auto&& a={expression}`来说，如果expression是类型为T的右值，那么auto就会推导为右值引用，最终a的类型就是一个对右值的引用。如果expression是类型为T的左值，那么auto就会推到为左值引用，最终a的类型就是一个对于左值的引用。

所以无论expression是左值还是右值，auto&&都可以顺利的完成推导。

## 回到std::move()

让我们回到std::move()

现在再来看，std::move的形参设计就非常清晰了，`_Ty&&可以适配任何左右值的输入`

```C++
x template <class _Ty> 
_NODISCARD constexpr remove_reference_t<_Ty>&& 
    				move(_Ty&& _Arg) noexcept { // forward _Arg as movable    
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);}
```

当我们拿到了对于输入值的类型之后，下面一步就是去除类型，然后把它变为右值（还记得std::move的目的吗？）

这里显然就是由`remove_reference_t`实现的，那么这个`remove_reference_t`是啥呢：

```c++
template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

```

原来，`remove_reference_t`是一个别名，它是`remove_reference<_Ty>`这个类的类型成员:

```c++
template <class _Ty>
struct remove_reference {
    using type  = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};
```

typename显示的指定了remove_reference<_Ty>::type是一个类型。如果上述T&& 推导的结果为左值，匹配的就是第二个remove_reference<\_Ty&>，因此type就是去掉了引用了类型。

再来看return：

```C++
 return static_cast<remove_reference_t<_Ty>&&>(_Arg);
```

改写一下就是：

```
 return static_cast<T&&>(_Arg);
```

这样，就成功的将任意一个左值或者右值转换为右值了

## 右值与移动语义的作用

我的理解主要是性能上的优化，这里举两个例子：

### 1. 针对指针的移动语义

```c++
class A{
public:
	int arr[1000000];
   	A(const A&){
        arr=new int[1000000];
        ...
    }
}
```

如果我们想要深拷贝一个A类型的对象，那么不需要想，成本也是巨大无比，a数组里面足足有好多好多个数字。

如果一个A对象，我们初始化完成之后，就不再使用它了，或则是想把它push_back进一个vector的话，我们这时候就可以使用移动语义了:

```c++
class A{
public:
	int arr[1000000];
   	A(A&& a){
   		arr=a.arr;
   		a.arr=nullptr;
        ...
   	}
}
```

轻松的完成了所有权的转换。

### 2. 针对函数返回值

看下面的函数：

```c++
A func(){
	A a;
	...对着a一通操作
	return a；
}

A b=func();
```

func()返回的值，毫无疑问是右值，但是当没有移动构造函数的时候。调用的是拷贝语义，然而就如同第一个情况一样，如果A类型内部有一个很大的数组，那么这个行为是很费时的。

因此:

```C++
A func(){    
    A a;    
	...对着a一通操作    
	return a；
}
A b=std::move(func());
```

就会省去很多的实践。

## 移动之后

现在让我们考虑移动操作之后，原来的右值会发生什么，或者说，我们应该让原来的右值做什么样的准备？

答案是，要让他准备析构。更准确的说，是要让原来的右值处于一个容易析构的状态，比如指针置为空等等。

移动语义发生之后的右值并不是直接就消失了，在stackoverflow上我看到了一个很好的比喻，移动就像是捐献器官，捐献者捐出了一个肾脏，不代表他就直接死了，如果在他死亡（生命周期结束）之前，给他又装了一个肾脏，那他就又活了。所以我们不能默认移动语义就只对移动后的对象操作，对于移动的数据的来源，也需要进行一些归于初始化的操作。



## Reference

[1] 《C++程序设计语言 4th》 Bjarne Stroustrup

[2]《C++11中的通用引用》Yuanguo's Blog https://www.yuanguohuo.com/2018/05/25/cpp11-universal-ref/
