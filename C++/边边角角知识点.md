# 边边角角知识点

## 在C++当中，如何操纵一个bit？

可以在struct当中使用位域(bit filed)。——《C++程序设计语言 4th》8.2.7

## UD：操作临时变量

```c++
string s1,s2="abc";
const char* csp=(s1+s2).c_str();
```

这里其实是一个错误的做法，因为s1+s2的时候，会生成一个临时变量。而c_str（）会返回这个临时变量的地址赋给csp，但是按理来说，这句语句结束之后，临时变量就会被释放，csp指向什么完全依靠编译器优化。

## extern “C”

这里的“C”定义的是链接方式，后面跟随的函数或者对象的类型检查和参数转换依然遵循严格的C++标准。

## enum和enum class

1. 声明和定义

enum不支持单独的声明，必须声明和定义同时出现

enum class可以

```c++
enum a; //错误的 error: use of enum 'a' without previous declaration 
enum class b; //正确
int main(){/****/	}
```

2. 作用域

enum内部定义的枚举值的作用域是和enum一级的

enum class定义的枚举值作用域是在enum class内部的

```c++
enum a1{
	i
};
enum a2{ //错误：test.cpp:5:2: error: 'i' conflicts with a previous declaration      
  	i	//		i
  		//		^
		//test.cpp:2:2: note: previous declaration 'a1 i'
  		//		i
  		//		^
};
enum class b1{//正确
	j		
};
enum class b2{//正确
	j
};
int main(){}
```

## 类内定义成员函数

众所周知，类的自身是有特殊处理的，因此满足ODR。但是类内的成员函数的链接性是外部链接。也就是说，如果在头文件当中完成了类成员函数的定义，那么它被重复包含的时候，就会重复定义：

```c++
//test.h
class A{
public:
	void func();
};
void A::func(){...}

//test1.cpp
#include"test.h"

//test2.cpp
#include"test.h"

//编译：
g++ -c test1.cpp test2.cpp -o test //报错，因为func（）被重复定义了
```

也因此，常用的方法都是讲类内部成员函数的定义放在.h对应的.cpp文件当中。但是，如果是在类内部直接定义成员函数，就不会冲突，这是为什么呢？

> 在C++当中，类内直接定义的成员函数是内联（inline）的，而inline的函数是满足ODR的

## 类中的const函数

1. 如果想要在const函数中修改某些成员变量（实现逻辑常量性），那么可以将需要修改的变量前加上mutable修饰《C++程序设计语言1-3 》 p397
2. const修饰符没有传递性，换句话说，在一个const函数内部，可以通过指针去间接修改指针指向对象的成员变量（也就是说指针自身是不可修改的，但是其指向的对象是可以修改的）

## test