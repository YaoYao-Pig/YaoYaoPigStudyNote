# 栈调用

https://www.cnblogs.com/findumars/p/7545818.html

对于Stack，涉及到两个指针，ESP和EBP。

ESP指针始终指向当前栈顶。

EBP的意义在于，标定当前的调用栈。

我们想象一种情况，main调用FuncA，然后FuncA调用了FuncB。

这时候，如何确定哪部分是哪个函数的栈帧呢。就是通过EBP。

下面从调用的时候梳理这个过程：Stack的增长是从高地址向低地址增长

#### 调用前 (Caller 的准备工作)

1. **参数压栈：** `Caller`函数按照**调用约定（Calling Convention）\**将参数`a`和`b`压入栈中。在C/C++默认的`cdecl`约定中，参数是\**从右向左**压栈的。
   - `push b` （`ESP` 减 4）
   - `push a` （`ESP` 减 4）
   - *此时，`ESP`指向参数`a`。*

#### 阶段2：`CALL` 指令 

1. `Caller`执行 `CALL func` 指令。
2. **返回地址压栈：** CPU 自动将`CALL`指令的**下一条指令**的地址（也就是`func`函数返回后应该继续执行的地方）压入栈中。这个地址被称为**返回地址（Return Address）**。  开始执行`func`。

#### 阶段3：函数序言 (Callee 的准备工作，"Prologue")

`func`函数（Callee）开始执行。它的开头部分通常是固定的“序言”代码：

1. **保存旧的 `EBP`：**
   - `push ebp`
   - *这非常重要！因为`EBP`中存的是`Caller`函数的栈帧基址，我们必须保存它，以便函数返回时能恢复`Caller`的栈帧。`ESP`现在指向这个旧的`EBP`值。*
2. **建立新栈帧：**
   - `mov ebp, esp`
   - *这是最关键的一步。`ESP`正指向刚才压入的旧`EBP`，现在`EBP`也被设置指向这个位置。从此刻起，`EBP`成为了`func`函数**新栈帧的基准点**，在`func`执行期间（几乎）不再改变。*
3. **为局部变量分配空间：**
   - `sub esp, N`
   - *`func`函数需要`N`个字节来存储它自己的局部变量（比如`int x; float y;`）。通过将`ESP`向下（低地址）移动`N`个字节，就在栈上“保留”了这块空间。*

> **小结：** 此时，栈帧已经建立完毕。
>
> - `EBP` 指向新栈帧的底部（保存旧`EBP`的位置）。
> - `ESP` 指向新栈帧的顶部（局部变量的末尾）。
> - `[ebp + 8]` 和 `[ebp + 12]` 分别是参数 `a` 和 `b`。
> - `[ebp + 4]` 是返回地址。
> - `[ebp - 4]`、`[ebp - 8]` ... 是`func`的局部变量。

#### 阶段4：函数尾声 (Callee 的返回准备，"Epilogue")

当`func`函数准备`return`时，它执行“尾声”代码，这是“序言”的逆操作：

1. **存储返回值 (回答你的问题)：**
   - 按照约定，简单的返回值（如`int`, `bool`, 指针）通常被放入`EAX`寄存器。
   - *（如果是浮点数，放入浮点寄存器`ST(0)`；如果是大的结构体，情况更复杂，通常是调用者预先分配好空间，并将地址作为隐藏参数传给`Callee`）。*
   - 假设是 `return result;`，编译器会生成 `mov eax, [result_location]`。
2. **释放局部变量空间：**
   - `mov esp, ebp`
   - *还记得`EBP`指向栈帧底部吗？这条指令直接把`ESP`拉回到`EBP`的位置，瞬间“丢弃”了所有局部变量（即阶段3中`sub esp, N`所分配的空间）。*
3. **恢复 `Caller` 的 `EBP`：**
   - `pop ebp`
   - *`ESP`现在指向之前保存的旧`EBP`（`Caller`的`EBP`），`pop`指令将其恢复到`EBP`寄存器。`ESP`随之增大4字节，现在指向返回地址。*

#### 阶段5：`RET` 指令

1. `Callee`执行 `RET` 指令。
2. **跳转回 `Caller`：** CPU 自动从栈顶（`ESP`正指向它）弹出返回地址，并将其加载到`EIP`（指令指针）中。（注意这里是EIP）
3. *CPU立即开始执行`Caller`函数中`CALL`指令之后的那条指令。*

#### 阶段6：栈清理 (Caller 的收尾工作)

1. `Caller`恢复执行，但此时，它压入栈的参数`a`和`b`还留在那里。
2. `Caller`需要清理这些参数。对于`cdecl`约定，`Caller`负责清理：
   - `add esp, 8`
   - *（因为`a`和`b`共占8字节）。`ESP`被加8，栈顶恢复到调用`func`之前的状态。*

## Stack里存储的到底是啥

栈里存储的其实就是中间临时变量，函数参数，中介结果等等。这个中间结果是因为CPU寄存器数量有限，有些很复杂的计算可能想要把一些中间变量存储在栈上。

## Stack里的变量的读取

指令在执行的时候是可以直接非栈顶的变量。

`IP`指向的那条指令（比如 `MOV`, `ADD`, `CMP` 等）这些指令被设计为可以访问内存中的**任意**合法地址。

CPU指令（`IP`指向的那些指令）使用一种叫做**“基址+偏移量”（Base + Offset）**的寻址模式来访问栈上的数据。

> **基址（Base）：** 使用 `EBP` 寄存器（那个“锚点”）。
>
> **偏移量（Offset）：** 一个编译时就计算好的**固定数字**。

```c++
[高地址]
    ...
    [EBP + 12]  <-- 参数 b
    [EBP + 8]   <-- 参数 a
    [EBP + 4]   <-- 返回地址
    [EBP]       <-- 保存的旧 EBP （EBP 正指向这里）
    [EBP - 4]   <-- 局部变量 x
    [EBP - 8]   <-- 局部变量 y
    ...
    [低地址] (ESP 可能在这里附近浮动)
```

当C++代码 `x = a + b;` 被编译成汇编时，它看起来可能（概念上）是这样的：

1. `MOV EAX, [EBP + 8]`
   - **解释：** `IP` 指向这条 `MOV` 指令。CPU执行它。这条指令说：“请把 `EBP` 寄存器的值加上 `8`，把那个内存地址（也就是参数 `a`）的数据加载到 `EAX` 寄存器。”
   - **结果：** `EAX` = `a`
2. `ADD EAX, [EBP + 12]`
   - **解释：** `IP` 现在指向这条 `ADD` 指令。CPU执行它。这条指令说：“请把 `EBP` 寄存器的值加上 `12`，取出那个地址（参数 `b`）的数据，和 `EAX` 寄存器里的值相加，结果存回 `EAX`。”
   - **结果：** `EAX` = `a + b`
3. `MOV [EBP - 4], EAX`
   - **解释：** `IP` 现在指向这条 `MOV` 指令。CPU执行它。这条指令说：“请把 `EAX` 寄存器里的值（`a + b`），存到 `EBP` 减去 `4` 的那个内存地址（局部变量 `x`）。”
   - **结果：** `x = a + b`

## 返回值

如何返回变量呢，分几个情况，如果是int，bool这种比较小的基本类型，那么就放在EAX，如果浮点数，存到浮点数，放入浮点寄存器`ST(0)`，如果是大的结构体，一般存在其他地方，并将地址作为隐藏参数传给`Callee`

## 调用模型

调用模型其实始终要记住，是有两个地址段在的。

一个是EIP，IP指针指向的是当前正在执行的指令序列。一个是ESP和EBP存储的是当前stack的指针

压栈的时候，压入的返回后的地址是EIP的地址，意思是当前调用完之后的下一条要执行的IP指针地址。 

我以前一直有一种错误的直觉就是感觉：

```c++
int main(){
    int a = func(b,c);
    int c = 0; 
}
```

我以前一直错误认为，上面这个是”调用栈“

但是实际上，上面这个实际上是，IP指针指向的指令流

stack实际上是一个数据存储的位置，一个中转站

