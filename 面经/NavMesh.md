# NavMesh

1. NavMesh生成

## 1. 体素化

首先是体素化，把空间划分成许多小立方体（提速）并且根据地形喝障碍标记体素可行走与不可行走。

## 2. 连通性分析

然后通过洪水算法分析体素，标记处所有联通的可行走区域。

## 3. 轮廓提取

在上述连通性分析完成之后，要进行轮廓提取。从联通的可行走区域中找出边界，

轮廓提取的核心是找到可行走区域的边缘，即可行走体素与不可行走体素（或场景边界）相邻的部分。这些边缘最终会形成NavMesh的边界轮廓：

- **边界体素**：如果一个可行走体素的某个相邻体素是不可行走的，或者位于场景边界之外，这个体素就被认为是边界体素。
- **轮廓线**：通过连接这些边界体素的边缘，形成一条或多条闭合的轮廓线，代表可行走区域的外部或内部边界。

轮廓提取通常分为以下几个步骤：

##### **3.1 识别边界体素**

- 对每个可行走体素，检查其在3D空间中的相邻体素。通常检查6个方向：前、后、左、右、上、下。
- 如果某个方向的相邻体素是不可行走的，或者不存在（即超出场景范围），则将该可行走体素标记为边界体素。
- 这一步的结果是一个包含所有边界体素的集合，它们构成了可行走区域的边缘。

##### **3.2 提取轮廓线**

- 从一个边界体素出发，沿着边界体素的边缘移动，追踪出一条闭合的轮廓线。

- 这个过程类似于图像处理中的边缘检测，常用方法是

  边界跟踪算法（Boundary Tracing）

  - 从起始边界体素开始，顺时针或逆时针检查相邻的体素，找到下一个边界体素。
  - 沿着边缘移动，记录经过的体素边缘，直到回到起点，形成闭合的轮廓。

- 如果场景中有多个独立的连通区域，则对每个区域重复此过程，生成多条轮廓线。

##### **3.3 轮廓简化**

- 直接提取的轮廓线可能包含大量顶点，尤其当体素较小时，轮廓会显得过于精细，增加了后续处理的复杂性。
- 为了优化NavMesh的结构，通常需要简化轮廓线，去除冗余顶点，同时保留关键的形状特征。
- **简化方法**：常用的算法包括**Douglas-Peucker算法**，通过递归去除对轮廓形状影响较小的顶点，减少顶点数量，提高效率。

##### **3.4 轮廓分类**

- 在复杂场景中，可能存在多个独立的连通区域，每个区域都会生成自己的轮廓线。
- 此外，如果可行走区域内部包含不可行走的部分（如障碍物），会同时生成外轮廓和内轮廓。
- 轮廓提取需要对这些轮廓进行分类，确保后续多边形化时能够正确处理内外边界。

## 4. 多边形化

在导航网格（NavMesh）生成过程中，轮廓提取完成后，**下一步是多边形化（Polygonization）**。这一步骤将提取出的轮廓线转化为一系列凸多边形，构成最终的NavMesh，为路径规划和代理移动提供支持。

### **多边形化的作用**

多边形化的核心目的是将复杂的轮廓区域转化为易于处理的凸多边形网格，主要原因包括：

- **简化路径计算**：凸多边形便于路径规划算法（如A*算法）计算最优路径。
- **支持代理移动**：确保代理在NavMesh上移动时路径平滑，避免卡在复杂区域。
- **提高效率**：通过减少多边形数量，优化后续计算的性能。

### **多边形化的具体步骤**

多边形化通常分为以下几个阶段：

1. 轮廓三角化

   - 将轮廓线内的区域划分为多个三角形。

   - 常用方法：耳切法（Ear Clipping）或Delaunay三角剖分。

     

   - 目的：为后续合并提供基础的几何单元。

2. 三角形合并

   - 将相邻的三角形合并成更大的凸多边形。
   - 方法：检查相邻三角形的共边和夹角，确保合并后仍为凸形。
   - 目的：减少多边形数量，提升路径规划效率。

3. 凸多边形优化

   - 调整生成的凸多边形，消除过小或过大的区域。
   - 目的：确保NavMesh适合代理的移动需求，提供流畅的体验。

### **后续应用**

完成多边形化后，生成的NavMesh将用于：

- **路径规划**：代理通过A*等算法计算最优路径。
- **代理移动**：代理沿着路径在NavMesh上移动并避障。
- **动态更新**：在动态场景中，可能需要实时重新执行多边形化。









------



## 轮廓三角化

### 1. 耳切法（Ear Clipping）

**耳切法**是一种简单而直观的算法，用于将一个简单多边形（没有自相交的封闭多边形）分解成多个三角形。它的核心思想是通过逐步“切掉”多边形的“耳朵”来完成三角剖分。

#### **工作原理**

耳切法的核心是找到并移除多边形中的“耳朵”。一个“耳朵”是指由三个连续顶点构成的三角形，满足特定条件。算法的具体步骤如下：

1. 耳朵的定义

   ：

   - 在多边形中，三个连续顶点 $v_{i-1}, v_i, v_{i+1}$ 构成一个耳朵，如果：
     - 这三个顶点形成的三角形内部不包含多边形的其他顶点。
     - 这三个顶点按照多边形的走向（顺时针或逆时针）是凸的。

2. 算法步骤

   ：

   - **步骤 1**：从多边形中找到一个耳朵 $v_i$。
   - **步骤 2**：将这个耳朵对应的三角形 $v_{i-1}, v_i, v_{i+1}$ “切掉”，即移除顶点 $v_i$，并将 $v_{i-1}$ 和 $v_{i+1}$ 直接连接，形成新的多边形边界。
   - **步骤 3**：重复上述步骤，直到多边形只剩下三个顶点，此时它们自然形成一个三角形，算法结束。

3. 实现细节

   ：

   - 耳朵检测需要检查三角形内部是否包含其他顶点，可以通过点在多边形内的测试（例如射线法）来实现。
   - 为了高效操作，通常使用双向链表等数据结构来维护多边形的顶点列表，便于快速更新。

#### **优点**

- 实现简单，易于理解和编程。
- 对于大多数简单多边形都能很好地工作。

#### **缺点**

- 不适用于有洞或自相交的复杂多边形，需要额外的预处理。
- 时间复杂度在最坏情况下为 $O(n^2)$，其中 $n$ 是顶点数，因为每次检测耳朵时可能需要遍历所有顶点。

#### **应用场景**

耳切法常用于将多边形区域分解为三角形，以便在图形渲染或物理模拟中使用。

------

### 2. Delaunay三角剖分

**Delaunay三角剖分**是一种更高级的三角剖分方法，适用于将一组离散点集划分为三角形网格。它的核心特性是生成的三角形满足“Delaunay条件”，即没有点位于任何三角形的外接圆内部。这种性质使得三角形更加“均匀”，避免了过瘦长的三角形。

#### **工作原理**

Delaunay三角剖分的目标是生成一个高质量的三角形网格，具体步骤如下：

1. Delaunay条件

   ：

   - 对于点集中的任意四个点，如果其中一个点不在其他三个点构成的三角形的外接圆内，则这四个点不会形成“坏”的四边形。这种特性保证了三角形尽量接近等边三角形。

2. 算法步骤

   ：

   - **步骤 1**：从点集中选择一个初始三角形（通常需要一个足够大的“超级三角形”包含所有点）。
   - **步骤 2**：逐步添加新的点，每次插入一个点后，调整受影响的三角形，确保所有三角形满足Delaunay条件。
   - **步骤 3**：重复此过程，直到所有点都被加入到三角剖分中，最后移除超级三角形。

3. 实现细节

   ：

   - 常见的实现方法包括：
     - **增量插入法**：每次插入一个新点后，检查并翻转不满足Delaunay条件的边。
     - **分治法**：将点集递归分为小块，分别进行三角剖分后再合并。
   - 边翻转是关键操作，用于局部调整网格以恢复Delaunay性质。

#### **优点**

- 生成的三角形质量高，避免了瘦长三角形，适用于数值计算和路径规划。
- 在导航网格生成中，能提供更优的网格结构，便于后续路径搜索。

#### **缺点**

- 实现较复杂，需要处理边的翻转和局部调整。
- 对于大规模点集，计算开销较大，但可以通过优化算法（如Bowyer-Watson算法）提高效率。

#### **应用场景**

Delaunay三角剖分广泛用于地形建模、有限元分析，以及导航网格生成中将点集或轮廓分解为高质量三角形网格。

------

### **总结对比**

- **耳切法**：适用于简单多边形的三角剖分，算法简单，时间复杂度较高（$O(n^2)$），适合小型场景或渲染需求。
- **Delaunay三角剖分**：适用于点集的三角剖分，生成高质量网格，复杂度可优化到 $O(n \log n)$，更适合路径规划等对网格质量要求较高的场景。

这两种方法各有千秋，选择哪种取决于具体需求：如果你处理的是简单多边形分解，耳切法是不错的选择；如果需要高质量的三角形网格（如导航网格），Delaunay三角剖分更合适。