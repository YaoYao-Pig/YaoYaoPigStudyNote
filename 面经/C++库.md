# memcpy和memmove的区别

在 C/C++ 中，`memcpy` 和 `memmove` 都是用于在内存中拷贝指定字节数的数据的函数，但它们在处理 **源地址和目标地址重叠**（overlap）时的行为不同：

------

## 1. 函数原型

```c++
void* memcpy ( void* destination, const void* source, size_t num );
void* memmove( void* destination, const void* source, size_t num );
```

- `destination`：目标内存起始地址
- `source`：源内存起始地址
- `num`：需要拷贝的字节数

------

## 2. 主要区别

1. **`memcpy` 不支持重叠拷贝**
   - 如果源地址和目标地址（所涵盖的区间）发生重叠，其行为是**未定义**的（Undefined Behavior）。
   - 实际实现中，如果重叠并且目标区域在源的后部，可能会覆盖还没来得及拷贝的源数据，从而导致拷贝结果混乱。
2. **`memmove` 支持重叠拷贝**
   - 即使源和目标指向的内存区域有重叠，也能保证正确地拷贝。
   - 原理：在实现层面会先判断源和目标的相对位置，如果需要，会先从后往前（或从前往后）搬运数据，确保不会破坏尚未拷贝的数据。

------

## 3. 使用建议

- **在确定源、目标区域不重叠**时，可以使用 `memcpy`，通常它在大多数平台上是**最快**的拷贝函数。
- **在可能发生重叠的情况下**，必须使用 `memmove`，以保证拷贝结果正确。

如果你不确定是否存在重叠，或者为了安全起见，也可直接使用 `memmove`，但如果能明确确保没有重叠，也可以用 `memcpy` 获得更好的性能。

------

## 4. 简单示例

### 4.1 不重叠的情况

```c++
char src[10] = "abcdef";
char dst[10] = {0};

// 不重叠，安全使用 memcpy
memcpy(dst, src, 6);  // 拷贝 "abcdef\0"
printf("dst = %s\n", dst);  // 输出: "abcdef"
```

### 4.2 重叠的情况

```c++
char buf[] = "123456789";
// 需要把位置 2~5 的数据移动到位置 4~7 处
// 这里区域明显重叠
// src = buf + 2, dst = buf + 4, 区域 [2..5] -> [4..7] 有交叉

// 如果使用 memcpy，行为未定义，可能会出错
// memmove 保证正确搬移
memmove(buf + 4, buf + 2, 4);  

printf("buf = %s\n", buf);
// 根据移位后的结果，可以看到内容从索引2到5的4个字节移动到了索引4到7处
```

------

## 5. 小结

- **`memcpy`**：仅适用于**不重叠**的内存区域，速度更快；若区域重叠，行为未定义。
- **`memmove`**：可以处理**有重叠**的内存区域，使用更加安全，但通常稍微慢一点。

在编写底层内存操作时，务必确认源和目标是否重叠，以选择合适的函数。