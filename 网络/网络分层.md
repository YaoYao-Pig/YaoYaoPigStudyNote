# 网络分层

我一直不是很懂网络，为啥要分这么多层呢。

<img src="assets/licensed-image.jpeg" alt="OSI model vs TCP IP model comparison的图片" style="zoom: 25%;" />

**注意：在思考的时候，下面的层，越向下，就越在里面**

网络层 | 传输层 | 应用层 | Data

## 网络层

网络层负责：指导数据包从一个ip到另一个ip

## 传输层

网络层可以让一个数据包从一个ip到另一个ip，但是，如果只是这样，操作系统没法分辨来的这个数据包到底是给哪个网络程序的。也就导致了同时只能存在一个网络程序的运行。因此就有了端口port这个东西。

传输层协议就是为了解决这个问题而出现的，常见的比如UDP和TCP

**也就是说，网络层负责数据包的运输（ip），而传输层协议最基本的职责是校验以及端口。UDP实现了最基本的功能，而TCP加了一层可靠传输**

## 应用层

应用层是距离真正要传输的数据最近的一层，也是由Header + Data组成。

这个header一般是有需求才存在的，比如要实现应用层的可靠传输，就要用KCP，如果真的需求足够简单，应用层可以只有需要传输的Data

像ProtoBuf，其实就是一个用于序列化反序列化Data的库函数。也属于应用层，但不是应用层协议

定义数据的“格式” (如 KCP/ HTTP)

定义数据的“意义” (业务逻辑)

人机交互 (UI / API)

> ------
>
> ### 1. 定义数据的“格式” (如 Protobuf / HTTP)
>
> UDP 把一堆二进制数据（`byte[]`）扔给你，说：“给，这是刚才那个包裹里的东西，没坏。”
>
> 但这堆 `010101` 到底是啥？
>
> - 是一张图片？
> - 是一个网页 HTML？
> - 还是你定义的 `MoveReq` 移动请求？
>
> 传输层根本不管这堆数据的意思。**只有应用层知道这堆数据的格式。**
>
> - **你的工作：** 你调用 `Protobuf.Unpack`，把这堆乱码变成一个 `PlayerMove` 对象。这就是应用层协议。
> - **常见的应用层协议：** HTTP (网页), FTP (文件), SMTP (邮件), **Protobuf (你的游戏数据)**。
>
> ### 2. 定义数据的“意义” (业务逻辑)
>
> 包解出来了，是个 `MsgId = 1001`，内容是 `x=10, y=20`。 然后呢？
>
> - **TCP/UDP 不知道：** 它们送完货就下班了。
> - **应用层（你）要决定：**
>   - “哦，1001 是移动请求。”
>   - “我要调用 `player.MoveTo(10, 20)`。”
>   - “我要检查他有没有被定身，如果被定身了，忽略这个包。”
>
> 这就是 **业务逻辑**。应用层负责让数据产生实际的效果（比如让屏幕上的人动起来，或者扣除玩家的金币）。
>
> ### 3. 人机交互 (UI / API)
>
> 数据处理完了，结果给谁看？
>
> - **展示给用户：** 渲染画面，弹出窗口“登录成功”。
> - **提供给其他服务：** 返回一个 JSON 告诉前端“订单已支付”。

应用层是里数据包最近的那一个部分，例如，项目中，KCP是一个应用层协议，那么（KCP + MsgId + Protobuf），你的 **应用层数据** 其实长这样：

| **字节位置** | **成分**                  | **角色**         | **谁负责解析？**       |
| ------------ | ------------------------- | ---------------- | ---------------------- |
| **头部**     | **KCP Header** (24字节)   | **应用层协议头** | KCP 库代码             |
| **头部**     | **MsgId** (2字节)         | **自定义包头**   | NetworkHelper          |
| **身体**     | **Protobuf Data** (N字节) | **实际业务体**   | Protobuf 库 + 游戏逻辑 |