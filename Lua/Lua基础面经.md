# Pairs和IPair

![image-20250610233728443](assets/image-20250610233728443.png)

`pairs` 和 `ipairs` 的区别是 Lua 中一个非常基础且重要的概念。从您提供的源代码角度分析，它们的根本区别在于使用了**完全不同的迭代机制**，这直接导致了它们遍历范围和顺序的差异。

### `ipairs` 的实现原理：顺序的、基于整数索引的数组遍历

`ipairs` 的设计目标是像在其他语言中遍历一个**数组（Array）或列表（List）**一样，严格按照数字顺序进行。

- **核心实现**： `ipairs` 函数本身（在 `lbaselib.c` 中实现为 `luaB_ipairs`）并不执行遍历。它是一个**迭代器工厂**，它返回三个值给 `for` 循环：
  1. 一个自定义的、用C编写的迭代函数 `ipairsaux`。
  2. 被遍历的表 `t`（作为状态）。
  3. 初始索引值 `0`。
- **迭代函数 `ipairsaux` 的逻辑**： `for` 循环每次调用 `ipairsaux` 时，该函数会：
  1. 接收上一次的索引 `i`（第一次调用时是0）。
  2. 计算下一个索引：`i = i + 1`。
  3. 使用 `lua_geti(L, 1, i)` 从表 `t` 中获取整数键 `i` 对应的值。`lua_geti` 是一个专门用于高效获取整数键值的C API函数，它会优先查找表的数组部分。
  4. 检查获取到的值：
     - 如果值是 `nil`，说明遇到了数组的“空洞”或末尾，迭代就此**结束**。
     - 如果值不是 `nil`，则将新的索引 `i` 和这个值返回给 `for` 循环。
- **源码分析结论**： `ipairs` 的实现完全不依赖于表的哈希部分或通用的 `next` 函数。它的行为是固定的、可预测的：
  - **顺序性**：严格按照整数 `1, 2, 3, ...` 的顺序进行。
  - **范围**：只遍历表的**数组部分**。
  - **中断条件**：一旦遇到第一个值为 `nil` 的整数键，遍历就会立即停止，即使后面还有非 `nil` 的整数键值对。

### `pairs` 的实现原理：完整的、无序的哈希表遍历

`pairs` 的设计目标是遍历一个**字典（Dictionary）或哈希映射（Hash Map）**，确保表中的**每一个**元素都能被访问到，而不关心顺序。

- **核心实现**： `pairs` 函数（在 `lbaselib.c` 中实现为 `luaB_pairs`）在默认情况下（即没有 `__pairs` 元方法时），返回三个值给 `for` 循环：
  1. Lua 的**原生 `next` 函数**（在C层面对应于 `lua_next` API，其核心是 `ltable.c` 中的 `luaH_next` 函数）。
  2. 被遍历的表 `t`（作为状态）。
  3. 初始控制变量 `nil`。
- **迭代函数 `luaH_next` 的逻辑**： `luaH_next` 函数的设计是为了能走遍表中的所有键值对。它的内部遍历顺序如下：
  1. **首先，遍历数组部分**：它会从头到尾扫描表的数组部分 (`t->array`)。
  2. **然后，遍历哈希部分**：接着，它会从头到尾扫描表的哈希部分 (`t->node`)。
  3. 对于 Lua 程序员来说，哈希部分元素的存储位置取决于键的哈希值以及解决哈希冲突的策略，因此遍历哈希部分的顺序是**不确定的**。
- **源码分析结论**： `pairs` 的实现依赖于 Lua 表的底层数据结构，这决定了它的行为：
  - **完整性**：它保证会访问到表中的**所有**非`nil`元素，无论键是整数、字符串还是其他类型。
  - **无序性**：虽然内部有一个固定的遍历顺序（先数组后哈希），但由于哈希部分元素的存储位置不可预测，所以从用户的角度看，`pairs` 的遍历顺序是**不确定的**。
  - **健壮性**：它会跳过值为 `nil` 的键（因为在 Lua 中，给一个键赋值 `nil` 等同于从表中删除这个键），所以不会像 `ipairs` 那样因为一个“空洞”而提前中断。

### 总结对比

| 特性         | `ipairs` (源码角度)           | `pairs` (源码角度)                         |
| ------------ | ----------------------------- | ------------------------------------------ |
| **迭代函数** | 自定义 C 函数 `ipairsaux`     | 原生 C 函数 `luaH_next` (通过 `next` 暴露) |
| **核心操作** | `lua_geti`，按序递增整数索引  | 遍历表内部的数组和哈希两个数据结构         |
| **遍历范围** | 仅限从 1 开始的连续整数键     | 所有键值对                                 |
| **顺序**     | 严格按 `1, 2, 3, ...` 顺序    | **不确定**                                 |
| **中断条件** | 遇到第一个值为 `nil` 的整数键 | 遍历完所有元素                             |

Export to Sheets

从源码的角度看，`ipairs` 是一个为“数组”这种特定数据结构量身定制的高效、有序遍历器；而 `pairs` 则是一个通用的、用于“哈希表”这种数据结构的完整、但无序的遍历器。